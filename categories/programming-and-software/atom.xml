<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming & Software | David Xia]]></title>
  <link href="https://www.davidxia.com/categories/programming-and-software/atom.xml" rel="self"/>
  <link href="https://www.davidxia.com/"/>
  <updated>2019-05-26T00:51:59+02:00</updated>
  <id>https://www.davidxia.com/</id>
  <author>
    <name><![CDATA[David Xia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[More About Nginx DNS Resolution Than You Ever Wanted to Know]]></title>
    <link href="https://www.davidxia.com/2019/05/more-about-nginx-dns-resolution-than-you-ever-wanted-to-know/"/>
    <updated>2019-05-17T18:58:38+02:00</updated>
    <id>https://www.davidxia.com/2019/05/more-about-nginx-dns-resolution-than-you-ever-wanted-to-know</id>
    <content type="html"><![CDATA[<p>This is a post about Nginx&rsquo;s DNS resolution behavior I didn&rsquo;t know about but wish I did before I
started using Kubernetes (K8s).</p>

<h2>Nginx caches statically configured domains once</h2>

<h3>Symptoms</h3>

<p>I moved a backend service <code>foo</code> from running on a virtual
machine to K8s. Foo&rsquo;s clients include an Nginx instance configured with this <code>upstream</code>
block.</p>

<pre><code>upstream foo {
  server foo.example.com.;
}

server {
  ...

  location ~* /_foo/(.*) {
    proxy_pass https://foo/$1;
    ...
  }
}
</code></pre>

<p>K8s Pods can be rescheduled anytime so their IPs aren&rsquo;t stable. I&rsquo;m supposed to use K8s Services
to avoid caching these ephemeral Pod IPs. But in my case because of interoperability reasons I was
registering Pod IPs directly as A records for <code>foo.example.com.</code>. I started noticing that after my Pod
IPs changed either because of rescheduling or updating the Deployment, Nginx started throwing
<code>502 Bad Gateway</code> errors.</p>

<h3>Root Problem</h3>

<p>Nginx resolves statically configured domain names only once at startup or configuration
reload time. So Nginx resolved <code>foo.example.com.</code> once at startup to several Pod IPs and cached
them forever.</p>

<h3>Solution</h3>

<!-- more -->


<p>Using a variable for the domain name will make Nginx resolve and cache it using the TTL value of the
DNS response. So replace the <code>upstream</code> block with a variable. I have no idea why it has to be a
variable to make Nginx resolve the domain periodically.</p>

<pre><code>set $foo_url foo.example.com.;
</code></pre>

<p>And replace the <code>proxy_pass</code> line with</p>

<pre><code>  location ~* /_foo/(.*) {
    proxy_pass https://$foo_url/$1;
    ...
  }
</code></pre>

<p>This behavior isn&rsquo;t documented but has been observed empirically and discussed <a href="https://serverfault.com/a/593003/88755">here</a>, <a href="https://stackoverflow.com/a/41476524/553994">here</a>,
and <a href="https://www.ruby-forum.com/t/using-127-0-0-1-in-resolver/238180/4">here</a>. I also learned that this setup requires me to define a <code>resolver</code> in the Nginx configs.
<strong>For some reason Nginx resolves statically configured domains by querying the nameserver specified in
<code>/etc/resolv.conf</code> but periodically resolved domains require a completely different config
setting.</strong> I would love to know why.</p>

<p>The VM on which Nginx was running ran a Bind DNS server locally, so I set <code>resolver 127.0.0.1</code>.
I triggered the code path that made Nginx send requests to foo and saw periodic DNS queries
occurring with <code>sudo tcpdump -i lo -n dst port 53 | grep foo</code>.</p>

<h2>What if that Nginx is also running on K8s?</h2>

<h3>Problem</h3>

<p>I had another Nginx instance that also made requests to foo. This Nginx was running on K8s too. It
was created with this Deployment YAML.</p>

<pre><code class="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: openresty/openresty:trusty
        ports:
          - name: https
            containerPort: 443
            protocol: TCP
        volumeMounts:
          - name: nginx-config
            mountPath: /etc/nginx/conf.d
      volumes:
        - name: nginx-config
          configMap:
            name: nginx-config
</code></pre>

<p>The <code>nginx-config</code> ConfigMap was</p>

<pre><code class="yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  nginx.conf: |
    upstream foo {
      server foo.example.com.:443;
    }

    server {
      ...

      # use regex capture to preserve url path and query params
      location ~* /_foo/(.*) {
        proxy_pass https://foo/$1;
        ...
      }
    }
</code></pre>

<p>I replaced <code>upstream</code> with the same pattern above, but in this case when I needed to define
<code>resolver</code> I couldn&rsquo;t use <code>127.0.0.1</code> because there&rsquo;s no Bind running locally. I can&rsquo;t hardcode the
resolver because it might change.</p>

<h3>Solution: run Nginx and foo on the same K8s cluster and use the cluster-local Service DNS record</h3>

<p>If Nginx and foo run on the same K8s cluster, I can use the cluster-local DNS record created by a
K8s Service matching the foo Pods. A Service like this</p>

<pre><code class="yaml">apiVersion: v1
kind: Service
metadata:
  name: foo
  namespace: bar
...
</code></pre>

<p>will create a DNS A record <code>foo.bar.svc.cluster.local.</code> pointing to the K8s Service&rsquo;s IP.
Since this Service&rsquo;s IP is stable and it load balances requests to the underlying Pods, there&rsquo;s no need for Nginx to
periodically lookup the Pod IPs. I can keep the <code>upstream</code> block like so.</p>

<pre><code>upstream foo {
  server foo.bar.svc.cluster.local.:443;
}
</code></pre>

<p>As its name implies, <code>foo.bar.svc.cluster.local.</code> is only resolvable within the cluster. So
Nginx has to be running on the same cluster as foo.</p>

<h3>Solution: dynamically set the Nginx <code>resolver</code> equal to the system&rsquo;s when the Pod starts</h3>

<p>What if Nginx is on another K8s cluster? Then I can set <code>resolver</code> to the IP of one of the
nameservers in <code>/etc/resolv.conf</code>. After a bunch of tinkering I came up with this way to dynamically
set the Nginx <code>resolver</code> when the Pod starts. A placeholder for <code>resolver</code> is set in the Nginx
ConfigMap, and a command at Pod startup copies over the templated config and replaces the
placeholder with a nameserver IP from <code>/etc/resolv.conf</code>.</p>

<p>Change <code>nginx-config</code> ConfigMap to</p>

<pre><code class="yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  nginx.conf.template: |
    server {
      ...

      # This directive is dynamic because we set it to the
      # kube-dns Service IP which is different for each cluster.
      resolver $NAMESERVER;

      set $foo_url foo.example.com.;

      # use regex capture to preserve url path and query params
      location ~* /_foo/(.*) {
        proxy_pass https://$foo_url/$1;
        ...
      }
    }
</code></pre>

<p>Deployment YAML then becomes (note the added <code>command</code>, <code>args</code>, and new <code>volume</code> and <code>volumeMount</code>).</p>

<pre><code class="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: openresty/openresty:trusty
        command: ['/bin/bash', '-c']
        args:
        - |
          export NAMESERVER=$(grep 'nameserver' /etc/resolv.conf | awk '{print $2}' | tr '\n' ' ')
          echo "Nameserver is: $NAMESERVER"
          echo 'Copying nginx config'
          envsubst '$NAMESERVER' &lt; /etc/nginx/conf.d.template/nginx.conf.template &gt; /etc/nginx/conf.d/nginx.conf
          echo 'Using nginx config:'
          cat /etc/nginx/conf.d/nginx.conf
          echo 'Starting nginx'
          nginx -g 'daemon off;'
        ports:
          - name: https
            containerPort: 443
            protocol: TCP
        volumeMounts:
          - name: nginx-config-template
            mountPath: /etc/nginx/conf.d.template
          - name: nginx-config
            mountPath: /etc/nginx/conf.d
      volumes:
        - name: nginx-config
          emptyDir: {}
        - name: nginx-config-template
          configMap:
            name: nginx-config
</code></pre>

<p>A <code>volume</code> of type <code>emptyDir</code> is needed because recent versions of K8s made configMap volumes
read-only. EmptyDir types are writable.</p>

<p>Hopefully this helps some people out there who don&rsquo;t want to spend as much time as I did Googling
obscure Nginx behavior.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Upstream Kubernetes Java Models Is Much Better Than Raw YAML]]></title>
    <link href="https://www.davidxia.com/2018/11/using-upstream-kubernetes-java-models-is-much-better-than-raw-yaml/"/>
    <updated>2018-11-11T23:11:38+01:00</updated>
    <id>https://www.davidxia.com/2018/11/using-upstream-kubernetes-java-models-is-much-better-than-raw-yaml</id>
    <content type="html"><![CDATA[<p>It&rsquo;s been a while since I blogged about something tech related, but I had some
free time today.</p>

<p>Recently, I&rsquo;ve been trying to refactor an internal Spotify deployment tool my
team built and maintains. This deployment tool takes Kubernetes (k8s) YAML
manifests, changes them, and essentially runs <code>kubectl apply</code>. We add metadata
to the k8s manifests like labels.</p>

<p>Right now this tool receives the input YAML as strings, converts them to
Jackson ObjectNodes, and manipulates those ObjectNodes. The disadvantage of
this is that there&rsquo;s no k8s type-safety. We might accidentally add a field to a
Deployment that isn&rsquo;t valid or remove something from a Service that&rsquo;s required.</p>

<p>My refactor uses upstream k8s model classes from <a href="https://github.com/kubernetes-client/java">kubernetes-client/java</a>
which are themselves <a href="https://github.com/kubernetes-client/gen">generated</a> from the official Swagger spec. Here&rsquo;s a
helpful Yaml utility class that deserializes YAML strings into concrete classes
and can also serialize them back into YAML strings. So helpful.</p>

<p>Unfortunately, there&rsquo;s some bugs in the YAML (de)serialization that prevent me
from finishing this effort.</p>

<ul>
<li><a href="https://github.com/kubernetes-client/java/pull/417">kubernetes-client/java issue 417</a></li>
<li><a href="https://github.com/kubernetes-client/java/issues/431">kubernetes-client/java issue 431</a></li>
<li><a href="https://github.com/kubernetes-client/java/issues/340">kubernetes-client/java issue 340</a></li>
</ul>


<p>Nonetheless, it&rsquo;ll be much nicer to change k8s resources in a type-safe way
instead of parsing and rewriting raw YAML strings.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Useful Site for TLS Server Test]]></title>
    <link href="https://www.davidxia.com/2017/05/useful-site-for-testing-tls-server-configuration/"/>
    <updated>2017-05-20T18:49:20+02:00</updated>
    <id>https://www.davidxia.com/2017/05/useful-site-for-testing-tls-server-configuration</id>
    <content type="html"><![CDATA[<p>My home server&rsquo;s hard disk&rsquo;s partition map was somehow corrupted. So I&rsquo;m serving this website
from <a href="https://m.do.co/c/74c553045962">Digital Ocean</a> for now instead of my apartment. While rewriting the nginx server configs,
I found this useful site that <a href="https://www.ssllabs.com/ssltest/index.html">tests your server&rsquo;s TLS configuration</a>. It&rsquo;ll give you a grade
and warn you of weak encryption, key exchange protocols, cipher suites, etc.</p>

<p><a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/">Mozilla&rsquo;s TLS configuration generator</a> is useful for providing secure defaults.</p>

<p>I&rsquo;m proud to say this site has an A.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My QCon NYC 2016 Slides - Reach Production Faster With Containers in Testing]]></title>
    <link href="https://www.davidxia.com/2016/06/my-qcon-nyc-2016-slides/"/>
    <updated>2016-06-20T23:15:49+02:00</updated>
    <id>https://www.davidxia.com/2016/06/my-qcon-nyc-2016-slides</id>
    <content type="html"><![CDATA[<p>Here are the slides from my <a href="https://qconnewyork.com/ny2016/presentation/reaching-production-faster-with-containers-in-testing">QCon NYC 2016 talk titled &ldquo;Reach Production Faster with Containers in
Testing.&rdquo;</a> in various formats. <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">All formats of &ldquo;Reach Production Faster with Containers in Testing&rdquo;</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://www.davidxia.com/2016/06/my-qcon-nyc-2016-slides-reach-production-faster-with-containers-in-testing/" property="cc:attributionName" rel="cc:attributionURL">David Xia</a> are licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/key/p1uEfRmocwplbk" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/DavidXia/qcon-nyc-2016-reach-production-faster-with-containers-in-testing" title="QCon NYC 2016: Reach Production Faster with Containers in Testing" target="_blank">QCon NYC 2016: Reach Production Faster with Containers in Testing</a> </strong> from <strong><a href="//www.slideshare.net/DavidXia" target="_blank">David Xia</a></strong> </div></p>

<p>More formats here:</p>

<ul>
<li><a href="https://drive.google.com/file/d/0By_v8MtsRMKkSloyT3gxalRuYjQ/view?usp=sharing">PDF</a></li>
<li><a href="https://drive.google.com/file/d/0By_v8MtsRMKkSm9BVW5uWFR5TFk/view?usp=sharing">Keynote</a></li>
<li><a href="https://drive.google.com/file/d/0By_v8MtsRMKkRkpQWk5paUZOUW8/view?usp=sharing">PowerPoint</a></li>
</ul>


<p>{% img center <a href="https://i.imgur.com/w0P47Ugl.jpg">https://i.imgur.com/w0P47Ugl.jpg</a> 640 619 %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PGP Best Practices - How to Create Strong and Secure Keys]]></title>
    <link href="https://www.davidxia.com/2015/05/pgp-best-practices-how-to-create-strong-and-secure-keys/"/>
    <updated>2015-05-02T00:00:00+02:00</updated>
    <id>https://www.davidxia.com/2015/05/pgp-best-practices-how-to-create-strong-and-secure-keys</id>
    <content type="html"><![CDATA[<p>I <a href="https://www.davidxia.com/2013/09/intro-to-public-key-cryptography-and-gpg/" title="Intro to public key cryptography and GPG">wrote about PGP</a> a while ago and showed how to generate a key. Since then I&rsquo;ve managed to do what
you should never, ever do: forget your key&rsquo;s passphrase. And I didn&rsquo;t generate a revocation cert to
boot. So I was screwed and had to generate a new one. Forunately not many, and by &ldquo;not many&rdquo; I mean
zero, people were using that public key which I had uploaded to public keyservers.</p>

<p>I generated a new one and spent a lot of time reading about PGP best practices. Here&rsquo;s what I
learned.</p>

<!-- more -->


<h2>How to Generate Strong Keys and Secure Them</h2>

<ul>
<li>Use GnuPG version &gt;= 1.4 to make it easier to generate and manage keys

<ul>
<li>You can <code>brew install gpg2</code> on a Mac</li>
</ul>
</li>
<li>Append the following to <code>~/.gnupg/gpg.conf</code> (or whatever the latest strongest encryption
algorithms are):</li>
</ul>


<pre><code>personal-digest-preferences SHA256
cert-digest-algo SHA256
default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed
</code></pre>

<ul>
<li><code>gpg --gen-key</code></li>
<li>Choose 1 at this prompt</li>
</ul>


<pre><code>Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
</code></pre>

<ul>
<li>Set an expiration date of at most two years (you can always extend it)</li>
<li>Set a strong passphrase that you&rsquo;ll remember!</li>
<li>Use the maximum number of bits for your key</li>
<li>Generate revocation cert(s)

<ul>
<li><code>gpg --gen-revoke &lt;key id&gt;</code> key id can be the portion of the fingerprint you see in
<code>gpg --list-keys</code> or the uid if it&rsquo;s unique</li>
</ul>
</li>
<li>Use subkeys for encryption (this is automatically done if you choose 1 above) and another for
signing. The following was copied from the <a href="https://wiki.debian.org/Subkeys" title="Debian wiki - subkeys">Debian wiki</a>.

<ul>
<li>Here&rsquo;s the best paragraph from that wiki page:</li>
</ul>
</li>
</ul>


<p>{% blockquote_nobr subkeys <a href="https://wiki.debian.org/Subkeys">https://wiki.debian.org/Subkeys</a> %}
You should keep your private master key very, very safe. However, keeping all your keys extremely
safe is inconvenient: every time you need to sign a new package upload, you need to copy the
packages onto suitable portable media, go into your sub-basement, prove to the armed guards that
you&rsquo;re you by using several methods of biometric and other identification, go through a deadly
maze, feed the guard dogs the right kind of meat, and then finally open the safe, get out the
signing laptop, and sign the packages. Then do the reverse to get back up to your Internet
connection for uploading the packages.
{% endblockquote_nobr %}</p>

<ul>
<li><code>gpg --edit-key &lt;your master key id&gt;</code></li>
<li>At the prompt, enter <code>addkey</code></li>
<li>Enter passphrase</li>
<li>Choose the &ldquo;RSA (sign only)&rdquo; key type and pick the maximum bits</li>
<li>Choose an expiry date</li>
<li><code>save</code></li>
<li>Backup the <code>~/.gnupg</code> directory and store it somewhere secure and offline.
Do this before deleting the private master key in the next step.</li>
<li>Check <code>gpg --export-secret-key &lt;your master key id&gt; | gpg --list-packets</code> does not show
<code>gnu-dummy 52K, algo: 0, ...</code>. This means your private master key is there.</li>
<li><code>gpg --export-secret-subkeys &lt;your master key id&gt; &gt; secret-subkeys</code></li>
<li><code>gpg --delete-secret-key &lt;your master key id&gt;</code></li>
<li><code>gpg --import secret-subkeys</code></li>
<li>Verify that <code>gpg -K</code> shows a &ldquo;sec#&rdquo; instead of just &ldquo;sec&rdquo; for your private key. That means the
secret key is not really there. You can see the presence of a dummy OpenPGP packet if you run
<code>gpg --export-secret-key &lt;your master key id&gt; | gpg --list-packets</code>.</li>
<li><code>gpg --keyserver some.keyserver.com --send-keys &lt;your master key id&gt;</code> to publish it to the world</li>
</ul>


<h2>How to Revoke</h2>

<p>If you ever need to revoke your keys,</p>

<pre><code>gpg --import path/to/revocation-cert
gpg --keyserver some.keyserver.com --send-key &lt;key id&gt;
</code></pre>

<h2>How to Sign Other People&rsquo;s keys</h2>

<p>Sign their key with a certain level of trust.</p>

<pre><code>gpg -u david@davidxia.com --sign-key --ask-cert-level harvey@harveyxia.com
</code></pre>

<p>Export the signed key and email it back to the signee.</p>

<pre><code>gpg --armor --output 00AA11BB-signedBy-1A2B3C4D.asc --export 00AA11BB
</code></pre>

<p>The signee needs to import the signed key</p>

<pre><code>gpg --import 1A2B3C4D-signedBy-00AA11BB.asc
</code></pre>

<p>and send your certification to the keyserver.</p>

<pre><code>gpg --send-key 1A2B3C4D
</code></pre>

<h2>Encrypting messages</h2>

<pre><code>gpg -u david@davidxia.com --recipient harvey@harveyxia.com --output msg.asc --encrypt msg
</code></pre>

<p>Recipients decrypt with <code>gpg -u harvey@harveyxia.com --output msg --decrypt msg.asc</code>.</p>

<h2>Signing messages</h2>

<pre><code>gpg -u david@davidxia.com --output msg.sig --detach-sign msg
</code></pre>

<p>Recipients verify with <code>gpg --verify msg.sig msg</code>. They should see &ldquo;Good signature from&hellip;&rdquo;</p>

<h2>References</h2>

<ul>
<li>a super readable introduction titled <a href="http://www.pgpi.org/doc/pgpintro/" title="How PGP Works">&ldquo;How PGP Works&rdquo;</a></li>
<li>More info <a href="http://ekaia.org/blog/2009/05/10/creating-new-gpgkey/" title="Creating a new GPG Key">here</a>, <a href="https://alexcabal.com/creating-the-perfect-gpg-keypair/" title="Creating the Perfect GPG Keypair">here</a>, and <a href="https://help.riseup.net/en/security/message-security/openpgp/best-practices" title="OpenPGP Best Practices">here</a> on best practices</li>
</ul>

]]></content>
  </entry>
  
</feed>
